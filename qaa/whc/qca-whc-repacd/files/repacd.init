#!/bin/sh /etc/rc.common
# Copyright (c) 2015, 2017-2019 Qualcomm Technologies, Inc.
#
# All Rights Reserved.
# Confidential and Proprietary - Qualcomm Technologies, Inc.
#
# 2015 Qualcomm Atheros, Inc.
#
# All Rights Reserved.
# Qualcomm Atheros Confidential and Proprietary.


# shellcheck disable=SC2034
START=97  # needs to be after LED init

# shellcheck disable=SC2034
SERVICE_WRITE_PID=1

# shellcheck disable=SC2034
SERVICE_DAEMONIZE=1

#SERVICE_DEBUG=1
NETWORK_RESTART=0
SERVICE_DEBUG_OUTPUT=0
REPACD_DEBUG_OUTOUT=0

# These restart_in_*_mode commands are only intended to be used by
# repacd-run.sh.
#
# - restart_in_cap_mode is used when the device has a direct connection to the
#   the gateway via ethernet. This will result in only the AP interfaces being
#   enabled.
# - restart_in_noncap_mode is used when the device no longer has a direct
#   connection to the gateway via ethernet. When this is done, the device will
#   either have both its AP and STA interfaces enabled (if its primary purpose
#   is as a standalone RE) or just its STA interface enabled (if its primary
#   purpose is as a client device).
# - restart_in_re_mode is used when a device that is intended to primarily
#   act as a client actually has sufficient link quality to act as a range
#   extender. It will enable both the STA and AP interfaces.
EXTRA_COMMANDS="restart_in_cap_mode restart_in_noncap_mode restart_in_re_mode"
EXTRA_HELP=<<EOF
        restart_in_cap_mode Reconfigure the system into Central AP mode
        restart_in_noncap_mode Reconfigure the system into Non Central AP mode
        restart_in_re_mode Reconfigure the system into Range Extender mode
EOF

WSPLCD_INIT='/etc/init.d/wsplcd'
HYFI_BRIDGING_INIT='/etc/init.d/hyfi-bridging'
config_load 'repacd'
config_get_bool ezmesh repacd 'Ezmesh' '0'
    if [ "$ezmesh" -eq 1 ]; then
        HYD_INIT='/etc/init.d/ezmesh'
        MAP='ezmesh'
        MAPLBD='ezlbd'
    else
        HYD_INIT='/etc/init.d/hyd'
        MAP='hyd'
        MAPLBD='lbd'
    fi
LBD_INIT='/etc/init.d/lbd'
MCSD_INIT='/etc/init.d/mcsd'

WSPLCD_MAP_DIR='/etc/wsplcd/map'
WSPLCD_MAP_BSS_POLICY_PATH="${WSPLCD_MAP_DIR}/bss-policy.conf"
WSPLCD_MAP_TEMPLATE_DIR="${WSPLCD_MAP_DIR}/templates"

. /lib/functions/whc-debug.sh
. /lib/functions/whc-iface.sh
. /lib/functions/whc-network.sh
. /lib/functions/repacd-netdet.sh

RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR='70'
RE_ROOT_AP_DISTANCE_INVALID='255'

#Increasing MAP_MAX_ADDITIONA_VAP needs changes also in all scheme template file
MAP_MAX_ADDITIONA_VAP=3

managed_network='' config_changed=0 map_bsta_max_preference=0
vap_defconf=1
config_re_mode='' resolved_re_mode='' resolved_re_submode=''
wsplcd_enabled=0 wsplcd_start=0 wsplcd_stop=0 wsplcd_restart=0
hyd_start=0 hyd_stop=0
resolved_ssid='' resolved_enc='' resolved_key=''

network_guest=
guest_backhaul_iface=
network_backhaul="backhaul"
backhaul_ssid='' backhaul_key='' backhaul_enc=''
def_backhaul_ssid="Backhaul" def_backhaul_key="1234567890" def_backhaul_enc="psk2+ccmp"
guest_ssid='' guest_enc='' guest_key=''
def_guest_ssid="Guest" def_guest_enc="none" def_guest_key=""
traffic_separation_enabled='' traffic_separation_active='' create_sta=0
daisy_chain=0 manage_vap_ind=0
bssid_resolve_state="resolving"
net_config_changed=0
lan_vid=100 guest_vid=102
eth_iface_wan="eth0"
eth_iface_lan="eth1"
eth_iface_wan_port=5
eth_iface_lan_port1=4
eth_iface_lan_port2=3

map_version=0 map_ts_enabled=0 num_vlan_supported=0
map_primary_nw='' map_backhaul_nw=''
map_single_r1r2_bh=0
map_primary_vlan=0
anqp_ele="272:34108cfdf0020df1f7000000733000030101"
map_num_radio=0

capsnr=0
Manage_front_and_back_hauls_ind=0
repacdPID=$(ps | grep repacd-run.sh | grep -v grep | awk '{print$1}')

# DPP
map_dpp_enabled=0
dpp_sta_found=0
dpp_config_key=0
dpp_key_len=0

#Creating a tmp file to identify the first boot of repacd
echo 1 > /tmp/firstboot

#check repacd config to enable/disable cfg80211
config_load 'repacd'
config_get_bool repacd_wxt repacd 'ForceWextMode' '0'
config_get def_backhaul_ssid repacd BackhaulSSID $def_backhaul_ssid

# Write the provided log message to the correct output stream.
# If REPACD_DEBUG_OUTOUT is non-zero, it will be written to the console.
# Otherwise, it will be written to stdout.
__repacd_echo() {
    if [ "$REPACD_DEBUG_OUTOUT" -gt 0 ]; then
        echo "whc (repacd): $*" > /dev/console
    else
        echo "whc (repacd): $*"
    fi
}

# Determine if the device is configured in gateway mode or not.
# Note that a device can still act as a CAP even if it is not in gateway
# mode, but this is detected later by the repacd-run.sh script.
# For WAN enabled gateway AP, check if wan interface name is configured
# For SDX-55 modem enabled gateway AP, check if wan protocol is set to 'rmnet'
# return: 0 if in gateway mode; otherwise non-zero
__repacd_gw_mode() {
    local wan_iface

    config_load network
    config_get wan_iface wan ifname
    config_get wan_proto wan proto 'dhcp'

    if [ -n "$wan_iface" ] || [ $wan_proto = "rmnet" ]; then
        return 0
    fi

    return 1
}

# Set bridge_empty option for the given network.
# This option allows to create empty_bridge.
#
# input: $1 network name
__repacd_set_bridge_empty() {
    local name="$1"
    local bridge_empty

    config_load network

    config_get bridge_empty "$name" 'bridge_empty' 0
    if [ "$bridge_empty" -eq 0 ]; then
        uci_set network "$name" bridge_empty '1'
    fi

    uci_commit network
}

# Determine if additional network exist.
# Currently looking out for only guest network.
#
# input: $1 network name
# return: 0 if exist; otherwise non-zero
__repacd_check_additional_network_exist() {
    config_load network

    if [ -n "$network_guest" ]; then
        if __repacd_network_exist $network_guest; then
            return 0
        fi
    fi

    return 1
}

# Get backhaul interfaces for ethernet.
# output: $1 - variable into which we populate interface(eth0.102 or eth1.102).
__repacd_get_backhaul_ifaces_eth_guest() {
    local ifaces
    local ifaces_guest_intf
    ifaces=$(ifconfig 2>&1 | grep eth | grep $guest_vid)
    ifaces_guest_intf=$(echo "$ifaces" | cut -d ' ' -f1)
    eval "$1='$ifaces_guest_intf'"
}

# Delete VLAN interfaces of backhaul vaps.
# input: $1 name of the interface config section
# input: $2 network name
# input: $3 VLAN id
# input: $4 mode 'sta' or 'ap'
# input-output: $5 change counter
__repacd_delete_vlan_interfaces() {
    local config=$1
    local id=$3
    local changed="$5"
    local ifname vlan_ifname
    local disabled mode bssid device hwmode

    config_get network "$config" network
    config_get ifname "$config" ifname
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode
    config_get device "$config" device
    config_get hwmode "$device" hwmode

    if [ "$hwmode" != "11ad" ]; then
        if [ "$network" = "$network_backhaul" ] && [ -n "$ifname" ] && \
            [ "$disabled" -eq 0 ]; then
            vlan_ifname=$(iwconfig 2>&1 | grep -o "$ifname.$id")
            if [ -n "$vlan_ifname" ]; then
               if __repacd_is_matching_mode "$4" "$mode"; then
                   vconfig rem "$ifname.$id"
                   brctl delif "br-$2" "$ifname.$id"
                   __repacd_delete_interface "$2" "$ifname.$id"
                   changed=$((changed + 1))
                   eval "$5='$changed'"
               fi
            fi
        fi
    fi
}

#Create Back haul interface for ethernet guest network and
#add it to the respective bridge
#input:$1 guest network name
#input-output:$2 change counter
__repacd_add_ethernet_vlan_interfaces() {
    local backhaul_ifaces_eth
    local network=$1
    local changed="$2"

    __repacd_get_backhaul_ifaces_eth_guest  backhaul_ifaces_eth
    if [ -n "$backhaul_ifaces_eth" ]; then
         __repacd_echo "Add VLAN ifaces for ethernet guest network support"
        if [ "$backhaul_ifaces_eth" = "$eth_iface_wan.$guest_vid" ] && [ "$network" = 'guest' ];then
             swconfig dev switch0 vlan $guest_vid set ports "0t ${eth_iface_wan_port}t ${eth_iface_lan_port1}t"
             swconfig dev switch0 set apply
             brctl addif "br-$network" "$backhaul_ifaces_eth"
             ifconfig "$backhaul_ifaces_eth" up
	      __repacd_add_interface "$network" "$backhaul_ifaces_eth"
	elif [ "$backhaul_ifaces_eth" = "$eth_iface_lan.$guest_vid" ] && [ "$network" = 'guest' ];then
             swconfig dev switch0 vlan $guest_vid set ports "0t ${eth_iface_lan_port1}t ${eth_iface_lan_port2}t"
             swconfig dev switch0 set apply
             brctl addif "br-$network" "$backhaul_ifaces_eth"
             ifconfig "$backhaul_ifaces_eth" up
	     __repacd_add_interface "$network" "$backhaul_ifaces_eth"
	else
             __repacd_echo "For Home network all the traffic is untagged,no vlan"
	fi
	#Do we really need to restart? revisit this
	changed=$((changed + 1))
	eval "$2='$changed'"
    fi

}

#Check if interface is ethernet interface
#input:$1 interface name
#return 1 if ethernet interface else 0
__repacd_is_eth_interface() {
    local iface_name=$1
    local ifaces_eth

    ifaces_eth=$(ifconfig 2>&1 | grep eth)
    ifaces=$(echo "$ifaces_eth" | cut -d ' ' -f1)
    for iface in $ifaces; do
        if [ "$iface" = "$iface_name" ]; then
            return 1
        fi
    done

    return 0
}

# Create necessary VLAN interfaces for the backhaul vaps and add the
# created VLAN interfaces to the given network.
# VLAN interfaces are created by concatenating interface name and vlan id.
# input: $1 config
# input: $2 network name
# input: $3 VLAN id
__repacd_map_add_vlan_backhaul() {
    local config="$1"
    local nw_name="$2"
    local vlan_id="$3"
    local iface network disabled device

    config_get ifname "$config" ifname
    config_get network "$config" network
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode
    config_get MapBSSType "$config" MapBSSType '0'

    if [ -n "$ifname" -a "$disabled" -eq 0 -a "$network" = "$map_backhaul_nw" \
            -a "$mode" = "ap" ]; then
        # if r2 STA Assoc DisAllowed do not create vlan
        if [ $(($((MapBSSType&4)) >> 2)) -eq 1 ]; then
            return
        fi

        if [ "$map_single_r1r2_bh" -eq 1 ]; then
            if [ "$nw_name" = "$map_primary_nw" ]; then
                __repacd_add_interface "$nw_name" "$ifname"
            fi
        fi

        __repacd_echo "Apply Vlan $ifname $vlan_id br-$nw_name"
        __repacd_add_interface "$nw_name" "$ifname.$vlan_id"
    fi
}

# Create necessary VLAN interfaces for ethernet interfaces and add the
# created VLAN interfaces to the given network.
# VLAN interfaces are created by concatenating interface name and vlan id.
# input: $1 network name
# input: $2 VLAN id
__repacd_map_add_vlan_ethernet() {
    local network="$1"
    local vlan_id="$2"

    iface_list=$(uci get "network.$map_primary_nw.ifname")
    for ifname in $iface_list; do
        __repacd_is_eth_interface $ifname
        is_eth_iface=$?
        if [ "$is_eth_iface" -eq 0 ]; then
            continue
        fi

        __repacd_echo "Apply Vlan $ifname $vlan_id br-$network"
        __repacd_add_interface "$network" "$ifname.$vlan_id"

        swconfig dev switch0 vlan $vlan_id set ports "0t 1t 2t 3t 4t"
        swconfig dev switch0 vlan $vlan_id set ports "0t 1t 2t 3t 4t"
        swconfig dev switch0 set apply
    done
}

# Create necessary VLAN interfaces for Easy Mesh
__repacd_map_apply_vlan_config() {
    __repacd_echo "Enable Easy Mesh Traffic Separation"
    local num_vlan=$num_vlan_supported

    # Create new bridge based on num Vlan configured by user
    config_load network
    for i in Primary One Two Three; do
        config_get nw_name MAPConfig "VlanNetwork"$i '0'
        config_get vlan_id MAPConfig "VlanIDNw"$i '0'

        if [ "$num_vlan" -eq 0 ]; then
            break
        fi

        if [ "$vlan_id" -eq 0 ]; then
            return
        fi

        # Configure backHaul BSS with VLAN for primary and secondary networks
        config_load wireless
        config_foreach __repacd_map_add_vlan_backhaul wifi-iface $nw_name $vlan_id

        # Configure ethernet interface with VLAN for secondary networks
        if [ "$i" != "Primary" ]; then
            __repacd_map_add_vlan_ethernet $nw_name $vlan_id
        fi

        num_vlan=$((num_vlan-1))
    done
}

# Create firewall rules for the given network if the rule does not exist.
# input: $1 network name
__repacd_set_firewall_rules() {
    local network=$1
    local no_rule
    local rule_name

    no_rule=$(uci show firewall | grep zone | grep "$network")

    if [ -z "$no_rule" ]; then
        local zone
        zone=$(uci add firewall zone)
        if [ -n "$zone" ]; then
            uci_set firewall "$zone" name "$network"
            uci add_list "firewall.$zone.network=$network"
            uci_set firewall "$zone" input 'REJECT'
            uci_set firewall "$zone" output 'ACCEPT'
            uci_set firewall "$zone" forward 'REJECT'

            local fwd
            fwd=$(uci add firewall forwarding)
            if [ -n "$fwd" ]; then
                uci_set firewall "$fwd" src "$network"
                uci_set firewall "$fwd" dest 'wan'
            fi

            local rule
            rule=$(uci add firewall rule)
            if [ -n "$rule" ]; then
                uci_set firewall "$rule" name 'Allow-DHCP-request'
                uci_set firewall "$rule" src "$network"
                uci_set firewall "$rule" src_port '67-68'
                uci_set firewall "$rule" dest_port '67-68'
                uci_set firewall "$rule" proto 'udp'
                uci_set firewall "$rule" target 'ACCEPT'
            fi

            rule=$(uci add firewall rule)
            if [ -n "$rule" ]; then
                uci_set firewall "$rule" name 'Allow-DNS-queries'
                uci_set firewall "$rule" src "$network"
                uci_set firewall "$rule" dest_port '53'
                uci_set firewall "$rule" proto 'tcpudp'
                uci_set firewall "$rule" target 'ACCEPT'
            fi

            rule=$(uci add firewall rule)
            if [ -n "$rule" ]; then
                rule_name="Block-$managed_network-$network-forwarding"
                uci_set firewall "$rule" name "$rule_name"
                uci_set firewall "$rule" src $managed_network
                uci_set firewall "$rule" dest "$network"
                uci_set firewall "$rule" proto '0'
                uci_set firewall "$rule" family 'any'
                uci_set firewall "$rule" target 'REJECT'
            fi

            rule=$(uci add firewall rule)
            if [ -n "$rule" ]; then
                rule_name="Block-$network-$managed_network-forwarding"
                uci_set firewall "$rule" name "$rule_name"
                uci_set firewall "$rule" src "$network"
                uci_set firewall "$rule" dest $managed_network
                uci_set firewall "$rule" proto '0'
                uci_set firewall "$rule" family 'any'
                uci_set firewall "$rule" target 'REJECT'
            fi
        fi
    fi
    uci_commit firewall
}

# Restart firewall.
__repacd_restart_firewall() {
    /etc/init.d/firewall restart
}

# Restart dnsmasq.
__repacd_restart_dnsmasq() {
    /etc/init.d/dnsmasq restart
}

# Create firewall rules for the given network if the rule does not exist.
# input: $1 nw_index network index
__repacd_set_firewall_dhcp_rules_map() {
    local nw_index=$1
    local network no_rule
    local dhcp_key dhcp_value dhcp_setting

    config_load repacd
    config_get network MAPConfig "VlanNetwork"$nw_index '0'
    config_get dhcp_setting MAPConfig "dhcpSettingsNw"$nw_index '0'

    # Set firewall rules for network
    __repacd_set_firewall_rules $network

    no_rule=$(uci show dhcp | grep zone | grep "$network")
    if [ -z "$no_rule" ]; then
        # DHCP Settings
        uci set dhcp.$network=dhcp
        uci set dhcp.$network.interface=$network
        uci set dhcp.$network.dhcpv6=server
        uci set dhcp.$network.ra=server

        for setting in $dhcp_setting
        do
            dhcp_key=$(echo "$setting" | cut -d '=' -f1)
            dhcp_value=$(echo "$setting" | cut -d '=' -f2)
            uci set dhcp.$network.$dhcp_key=$dhcp_value
        done

        uci_commit dhcp
    fi
}

# Check whether the given interface is the backhaul AP interface on
# the desired network and update the band specific interface names.
#
# input: $1 - config: the name of the interface config section
# input: $2 - network: the name of the network to which the AP interface
#                      must belong to be matched
# output: $3 - iface: the resolved backhaul AP interface name on 2.4 GHz (if found)
# output: $4 - iface: the resolved backhaul AP interface name on 5 GHz (if found)
# output: $5 - iface: the resolved backhaul AP interface name on 6 GHz (if found)
__repacd_wifi_check_and_get_backhaul_ap_iface() {
    local config="$1"
    local network_to_match="$2"
    local iface disabled mode device hwmode backhaul_ap

    config_get network "$config" network
    config_get iface "$config" ifname
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode
    config_get device "$config" device
    config_get backhaul_ap "$config" backhaul_ap '0'
    config_get hwmode "$device" hwmode
    config_get band "$device" band
    local band_freq=`iwlist $iface 2>&1 channel | grep "Current Frequency" | awk -F':' '{print $2}' | awk -F" " '{print $1}' | sed 's/\.//g' | sed -e "s/\<\([0-9]\{1,4\}\)\>/\10000/; s/\([0-9]\{4\}\)/\1/" | awk '{ print $1; }' | sed -n 's/\([0-9]\{4\}\).*/\1/p' `

    if [ "$hwmode" != "11ad" ]; then
        if [ "$network" = "$network_to_match" ] && [ -n "$iface" ] && [ "$mode" = "ap" ] \
            && [ "$backhaul_ap" -gt 0 ] && [ "$disabled" -eq 0 ]; then
            if [ "$hwmode" = "11axa" ] || [ "$hwmode" = "11ac" ] || [ "$hwmode" = "11na" ] || [ "$hwmode" = "11a" ]; then
                if [ "$band_freq" -gt 5950 ] && [ "$band_freq" -lt 7130 ]; then
                    eval "$5=$iface"
                fi
                if [ "$band_freq" -gt 5175 ] && [ "$band_freq" -lt 5900 ]; then
                    eval "$4=$iface"
                fi
            else
                eval "$3=$iface"
            fi
        fi
    fi
}

# Configure the otherband BSSIDs for both backhaul APs
# input: $1 - network: the name of the network to which the AP interface
#                      must belong to be matched
# output: None
__repacd_wifi_set_otherband_bssids() {
    local otherband_bssid24g1 otherband_bssid24g2 bssid_5g bssid_24g bssid_6g
    local otherband_bssid5g1 otherband_bssid5g2 otherband_bssid6g1 otherband_bssid6g2
    local backhaul_ap_iface_24g backhaul_ap_iface_5g backhaul_ap_iface_6g success=0 loop_count=30

    while [ "$success" -eq 0 ] && [ "$loop_count" -gt 0 ]; do
        config_load wireless
        config_foreach __repacd_wifi_check_and_get_backhaul_ap_iface wifi-iface "$1" \
            backhaul_ap_iface_24g backhaul_ap_iface_5g backhaul_ap_iface_6g
        if [ -n "$backhaul_ap_iface_5g" ] || [ -n "$backhaul_ap_iface_6g" ]; then
            if [ -n "$backhaul_ap_iface_5g" ] && [ -n "$backhaul_ap_iface_24g" ]; then
                bssid_5g=$(ifconfig "$backhaul_ap_iface_5g" | grep "HWaddr" | awk -F" " '{print $5}')
                bssid_24g=$(ifconfig "$backhaul_ap_iface_24g" | grep "HWaddr" | awk -F" " '{print $5}')
                otherband_bssid5g1=$(echo "$bssid_5g" | sed -e "s/://g" | cut -b 1-8)
                otherband_bssid5g2=$(echo "$bssid_5g" | sed -e "s/://g" | cut -b 9-12)
                otherband_bssid24g1=$(echo "$bssid_24g" | sed -e "s/://g" | cut -b 1-8)
                otherband_bssid24g2=$(echo "$bssid_24g" | sed -e "s/://g" | cut -b 9-12)
                cfg80211tool_mesh $backhaul_ap_iface_24g otherband_bssid 0x$otherband_bssid5g1 0x$otherband_bssid5g2
                cfg80211tool_mesh $backhaul_ap_iface_5g otherband_bssid 0x$otherband_bssid24g1 0x$otherband_bssid24g2
            fi
            if [ -n "$backhaul_ap_iface_6g" ]; then
                bssid_6g=$(ifconfig "$backhaul_ap_iface_6g" | grep "HWaddr" | awk -F" " '{print $5}')
                bssid_24g=$(ifconfig "$backhaul_ap_iface_24g" | grep "HWaddr" | awk -F" " '{print $5}')
                otherband_bssid6g1=$(echo "$bssid_5g" | sed -e "s/://g" | cut -b 1-8)
                otherband_bssid6g2=$(echo "$bssid_5g" | sed -e "s/://g" | cut -b 9-12)
                otherband_bssid24g1=$(echo "$bssid_24g" | sed -e "s/://g" | cut -b 1-8)
                otherband_bssid24g2=$(echo "$bssid_24g" | sed -e "s/://g" | cut -b 9-12)
                cfg80211tool_mesh $backhaul_ap_iface_6g otherband_bssid 0x$otherband_bssid24g1 0x$otherband_bssid24g2
                if [ -z "$backhaul_ap_iface_5g" ]; then
                cfg80211tool_mesh $backhaul_ap_iface_24g otherband_bssid 0x$otherband_bssid6g1 0x$otherband_bssid6g2
                fi
             fi
            success=1
        else
            sleep 1
            loop_count=$((loop_count - 1))
        fi
    done
}

# Enumerate all of the wifi interfaces and append
# only station devices to the variable provided.
# output: $1 devices: variable to populate with the station devices
__repacd_get_sta_devices() {
    local devices=$1

    config_cb() {
        local type="$1"
        local section="$2"

        case "$type" in
            wifi-iface)
                config_get mode "$section" mode
                config_get device "$section" device
                if [ "$mode" = 'sta' ];then
                    eval append $devices "$device"
                fi
            ;;
        esac
    }
    config_load wireless
}

# Configure the vap independent parameter for given wifi interface.
#
# input: $1 - config: interface config name to configure.
# input: $2 - devices: list of devices to match with provided interface.
__repacd_config_vap_ind() {
    local config=$1
    local devices=$2
    local match_found=0
    local device

    config_load wireless
    config_get device "$config" device

    for device_to_match in $devices; do
        if [ "$device" = "$device_to_match" ]; then
            if __repacd_is_son_mode; then
                # If in SON mode, STA vaps may be forced down based on
                # link strength so configure the VAPs in independent mode.
                # This will be used in conjunction with the other feature
                # that monitors the backhaul links and brings down the AP VAPs
                # if there is no backhaul for a sustained period of time.
                __repacd_update_vap_param "$config" 'athnewind' 1
            else
                __repacd_update_vap_param "$config" 'athnewind' 0
            fi
            match_found=1
        fi
    done

    # If the feature Manage Front-Haul VAPs independently based on
    # CAP's reachability is enabled, then set athnewind value to 1.
    if [ "$Manage_front_and_back_hauls_ind" -gt 0 ]; then
        __repacd_update_vap_param "$config" 'athnewind' 1

    # This is mainly for wsplcd optimization: if wsplcd detects athnewind
    # is set to 0, it will not restart VAP; otherwise it will bring down
    # the VAP, set athnewind to 0 and bring the VAP back up
    elif [ "$match_found" -eq 0 ]; then
        __repacd_update_vap_param "$config" 'athnewind' 0
    fi
}

# Configure the vap independent parameter for all VAPs
# only if repacd is allowed to configure this parameter.
# input: None
__repacd_config_independent_vaps() {
    local sta_devices=

    if [ "$manage_vap_ind" -gt 0 ]; then
        __repacd_get_sta_devices sta_devices
        __repacd_echo "Station device list = $sta_devices"

        config_foreach __repacd_config_vap_ind wifi-iface "$sta_devices"
    else
        # Pass empty device list, so that all vaps set to athnewind=0.
        config_foreach __repacd_config_vap_ind wifi-iface "$sta_devices"
    fi
}
# Determine the configured RE mode, not applying any automatic mode
# switching rules.
#
# output: $1 variable in which to place the resolved mode
__repacd_get_config_re_mode() {
    local resolved_mode=$1
    local mode

    config_load 'repacd'
    config_get mode repacd 'ConfigREMode' 'auto'

    eval "$resolved_mode=$mode"
}

# Determine whether the provided mode is an automatic mode.
#
# input: $1 mode: the mode to check
# return: 0 if the mode is an auto mode; otherwise 1
__repacd_is_auto_re_mode() {
    local mode=$1

    if [ "$mode" = 'auto' ]; then
        return 0
    fi

    return 1
}

# Resolve the current mode in which to operate the range extender.
#
# This mode is either the configured mode (if it is set to a specific
# mode), the automatically derived RE mode based on association information,
# or the default range extender mode for use at startup.
#
# output: $1 - the variable into which to place the resolved mode
__repacd_get_re_mode() {
    local resolved_mode=$1
    local mode default_mode

    __repacd_get_config_re_mode config_re_mode

    if __repacd_is_auto_re_mode $config_re_mode; then
        config_get default_mode repacd 'DefaultREMode' 'qwrap'
        config_get mode repacd 'AssocDerivedREMode' "$default_mode"
    else
        mode=$config_re_mode
    fi

    # Get the Association derived sub-mode. If not derived, say "star".
    config_get resolved_re_submode repacd 'AssocDerivedRESubMode' 'star'

    eval "$resolved_mode=$mode"
}

# Determine if the range extension mode is set to WDS.
#
# return: 0 if the mode is set to WDS; otherwise 1 (meaing QWrap or ExtAP)
__repacd_is_wds_mode() {
    __repacd_get_re_mode resolved_re_mode

    case "$resolved_re_mode" in
        wds|WDS)
            return 0
        ;;

        *)
            return 1
        ;;
    esac
}

# Determine if the range extension mode is set to QWrap.
#
# return: 0 if the mode is set to QWrap; otherwise 1 (meaning WDS or ExtAP)
__repacd_is_qwrap_mode() {
    __repacd_get_re_mode resolved_re_mode
    case "$resolved_re_mode" in
        qwrap|QWRAP)
            return 0
        ;;

        *)
            return 1
    esac
}

# Determine if the range extension mode is set to SON.
# Note that if the hyd init script is missing, this will be considered as
# SON mode disabled.
#
# return: 0 if the mode is set to SON; otherwise 1 (meaing WDS or an
#         interoperable range extension mode)
__repacd_is_son_mode() {
    if [ ! -f $HYD_INIT ]; then
        return 1
    fi

    __repacd_get_re_mode resolved_re_mode
    case "$resolved_re_mode" in
        son|SON)
            return 0
        ;;

        *)
            return 1
        ;;
    esac
}

# Determine whether the Multi-AP Topology Optimization algorithm is enabled.
#
# return: 0 if the algorithm is enabled; otherwise 1
__repacd_is_map_enabled() {
    local map_enabled

    config_load 'repacd'
    config_get_bool map_enabled MAPConfig 'Enable' '0'

    [ "$map_enabled" -gt 0 ]
    return $?
}

# Determine whether the Multi-AP Lite Mode is enabled.
#
# return: 0 if enabled; otherwise 1
__repacd_is_map_lite_enabled() {
    config_load 'repacd'
    config_get_bool map_lite_enabled MAPConfig 'EnableLiteMode' '0'

    [ "$map_lite_enabled" -gt 0 ]
    return $?
}

# Determine if DFS channels are to be blocked even for WDS mode.
#
# return: 0 if DFS channels should not be used; otherwise 1 (meaning they may
#         be used)
__repacd_is_block_dfs() {
    local block_dfs

    config_load 'repacd'
    config_get block_dfs repacd 'BlockDFSChannels' '0'

    if [ "$block_dfs" -gt 0 ]; then
        return 0
    else
        return 1
    fi
}

# Get the configured Rate scaling factor.
# Gives default value in case of configuration miss or invalid value.
#
# output: $1 - rate_scaling_factor
__repacd_get_rate_scaling_factor() {
    local scaling_factor

    config_load 'repacd'
    config_get scaling_factor WiFiLink 'RateScalingFactor' $RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR

    # If scaling factor out of limits, return the default value "70".
    if [ "$scaling_factor" -lt '1' ] || \
        [ "$scaling_factor" -gt '100' ]; then
        scaling_factor=$RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR
    fi

    eval "$1=$scaling_factor"
}

# check vap is in default configuration by comparing ssid as OpenWrt
# and encryption as none,for now any one VAP with this configuration
# is enough for marking configuration as default configuration.
# Internal driver currently does not support 11ad so ignoring
# 11ad enabled devices for now.
# input: $1 config: section to update
# input: $2 network: Global variable vap_defconf.
# input-output:$2 is set to '0' in case we have any VAP
# with default config.

__repacd_check_default_vaps() {
    local config="$1"

    config_get device "$config" device
    config_get ssid  "$config" ssid
    config_get encryption "$config" encryption
    config_get hwmode "$device" hwmode
    config_get type "$device" type
    config_get_bool repacd_security_unmanaged "$config" repacd_security_unmanaged '0'

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ] ;then
        return
    fi

    if [ "$repacd_security_unmanaged" -eq 1 ] ; then
        return
    fi

    if [ "$ssid" = "OpenWrt" ] && [ "$encryption" = "none" ] ;then
        eval "$2='0'"
    fi
}

# Determine if the VAPs are in the default configuration.
# For now this is defined simply as any VAP having the default SSID and no
# security enabled or that there are no VAPs whatsoever.
#
# return: 0 if in the default configuration; otherwise non-zero
__repacd_vaps_in_default_config() {
    local no_vaps

    # If there is no entry, uci will give an error message. We detect this
    # by looking for the string in the output.
    no_vaps=$(uci show wireless.@wifi-iface[-1] 2>&1 | grep 'Entry not found')
    [ -n "$no_vaps" ] && return 0

    config_load wireless
    config_foreach __repacd_check_default_vaps wifi-iface vap_defconf

    return $vap_defconf
}

# Generate a suffix for the SSID using the last 3 bytes of the MAC address
# on the bridge that is being managed.
#
# output: $1 - variable into which to write the SSID suffix
__repacd_generate_ssid_suffix() {
    local generated_suffix
    generated_suffix=$(ifconfig br-$managed_network | grep HWaddr | awk '{print $5}' | awk -F":" '{print $4$5$6}')
    eval "$1=$generated_suffix"
}

# Generate a random pre-shared key for use with WPA2
#
# output: $1 - variable into which to write the PSK
__repacd_generate_psk() {
    local generated_key
    generated_key=$(dd if=/dev/urandom bs=1 count=8 2> /dev/null | base64)
    eval "$1=$generated_key"
}

# Reconfigure all managed VAPs and create new ones as appropriate. This is
# non-destructive in that all configuration parameters for a VAP that are not
# directly controlled by this script will not be modified.
#
# This should generally only be called when starting with a fresh
# configuration (eg. at first boot or due to a user request), as it will
# generate an SSID and passphrase. See __repacd_reset_existing_config() for
# the function used when the SSID and passphrase configured are to be
# preserved.
__repacd_reset_default_config() {
    config_load wireless
    config_foreach __repacd_resolve_vaps wifi-iface $managed_network

    # Use last three bytes of the MAC address to help make the SSID unique.
    local ssid_suffix
    __repacd_generate_ssid_suffix ssid_suffix

    # Generate a random password (which will likely be changed either through
    # cloning or by the end user).
    local random_psk
    __repacd_generate_psk random_psk

    __repacd_create_vaps "whc-$ssid_suffix" 'psk2+ccmp' "$random_psk"
    uci_commit wireless
}

# Delete guest bridges, firewall and DHCP settings for guest networks
__repacd_map_delete_traffic_sep_config() {
    local is_controller=$1
    local bridges dhcp_uci br nw
    local ifaces_eth iface_wan ifaces

    # On reset delete all network configurations other than
    # primary
    bridges=$(uci show network | grep bridge)
    for br in $bridges; do
        nw=$(echo $br | cut -d "." -f 2)
        if [ "$map_primary_nw" != "$nw" ]; then
            uci delete network.$nw
        fi
    done

    # Clean Primary ifname list so any vlan configuration will
    # be erased and add ethernet interface to ifname
    uci_set network "$map_primary_nw" ifname ' '
    ifaces_eth=$(ifconfig -a 2>&1 | grep eth)
    iface_wan=$(uci get network.wan.ifname)
    ifaces=$(echo "$ifaces_eth" | cut -d ' ' -f1)
    for iface in $ifaces; do
        # Delete interface that is vlan configured
        echo "$iface" | grep '\.' >/dev/null 2>&1
        if [ "$?" -eq "0" ]; then
            continue
        fi

        # Add ethernet lan interface to primary ifname if link is detected
        if [ "$iface" != "$iface_wan" ]; then
            __repacd_add_interface $map_primary_nw $iface
        fi
    done

    # Reset Firewall and DHCP Settings on Controller
    if [ "$is_controller" -eq 1 ]; then
        # Copy default firewall config
        cp /rom/etc/config/firewall /etc/config/firewall

       # On reset delete all dhcp configurations other than
       # primary
       dhcp_uci=$(uci show dhcp | grep interface)
       for br in $dhcp_uci; do
           nw=$(echo $br | cut -d "." -f 2)
           if [ "$map_primary_nw" != "$nw" -a "wan" != "$nw" ]; then
               uci delete dhcp.$nw
           fi
       done
    fi

    if [ "$map_ts_enabled" -eq 0 ]; then
        __repacd_echo "Easy Mesh Traffic Separation Disabled"
        uci_set repacd MAPConfig 'MapTrafficSeparationActive' 0
        uci_set $MAP MultiAP 'NumberOfVLANSupported' 0
        uci_set $MAP MultiAP 'Map2TrafficSepEnabled' 0
        uci_set wsplcd config 'NumberOfVLANSupported' 0
        uci_set wsplcd config 'Map2TrafficSepEnabled' 0
        uci_set $MAP MultiAP 'Map8021QPCP' 0
        uci_set $MAP MultiAP 'FronthaulSSIDPrimary' ''
        uci_set $MAP MultiAP 'VlanIDNwPrimary' 0
        uci_set $MAP MultiAP 'FronthaulSSIDNwOne' ''
        uci_set $MAP MultiAP 'VlanIDNwOne' 0
        uci_set $MAP MultiAP 'FronthaulSSIDNwTwo' ''
        uci_set $MAP MultiAP 'VlanIDNwTwo' 0
        uci_set $MAP MultiAP 'FronthaulSSIDNwThree' ''
        uci_set $MAP MultiAP 'VlanIDNwThree' 0
        uci_set $MAP MultiAP 'AdditionalFH' ''
    fi
}

# Add or remove bridges based on user configuration. If traffic separation is
# enabled create bridge with network name, IP address and proto as specified
# by user. Add interface and vlanID for secondary bridge based on primary lan
# ifname list. If traffic separation is disabled remove all bridges except primary
# bridge
__repacd_map_reset_default_bridge_config() {
    local is_controller=$1
    local num_vlan=$num_vlan_supported

    __repacd_map_delete_traffic_sep_config $is_controller

    if [ "$map_ts_enabled" -eq 0 ]; then
        __repacd_echo "Easy Mesh Traffic Separation Disabled"
        return
    fi

    # Create new bridge based on num Vlan configured by user
    config_load network
    for i in One Two Three; do
        if [ "$num_vlan" -eq 0 -o "$num_vlan" -eq 1 ]; then
            break
        fi

        config_get nw_name MAPConfig "VlanNetwork"$i '0'
        config_get br_proto MAPConfig "BridgeProtoNw"$i '0'
        config_get br_ip MAPConfig "BridgeIPAddressNw"$i '0'

        __repacd_echo "Creating Bridge : br-$nw_name"
        __repacd_echo "Bridge Proto : $br_proto"
        __repacd_echo "Bridge IP : $br_ip"

        uci set network.$nw_name=interface
        uci_set network "$nw_name" type "bridge"
        uci_set network "$nw_name" proto $br_proto
        if [ "$br_proto" = "static" ]; then
            uci_set network "$nw_name" ipaddr $br_ip
        fi
        uci_set network "$nw_name" netmask "255.255.255.0"
        uci_set network "$nw_name" force_link 1
        uci_set network "$nw_name" family ipv4
        uci_set network "$nw_name" ifname ' '
        uci_set network "$nw_name" bridge_empty 1

        # Set firewall settings on controller for guest nw
        if [ "$is_controller" -eq 1 ]; then
            __repacd_set_firewall_dhcp_rules_map $i
        fi

        uci_commit network
        num_vlan=$((num_vlan-1))
    done

    # set bridge MAC
    __repacd_map_set_bridge_mac
}

# Set bridge MAC
__repacd_map_set_bridge_mac() {
    local num_vlan=$num_vlan_supported
    local ifaces_eth iface_wan ifaces
    local nw_name br_mac sameMAC

    config_get nw_name MAPConfig "VlanNetworkPrimary" '0'
    config_get sameMAC MAPConfig "TSUseSameBridgeMAC" '0'

    br_mac=$(ifconfig eth0 | grep HWaddr | awk '{print $5}')
    uci_set network "$nw_name" macaddr $br_mac
    ifconfig br-$nw_name hw ether "$br_mac"

    # Create new bridge based on num Vlan configured by user
    config_load network
    for i in One Two Three; do
        if [ "$num_vlan" -eq 0 -o "$num_vlan" -eq 1 ]; then
            break
        fi

        config_get nw_name MAPConfig "VlanNetwork"$i '0'
        if [ "$i" = "One" -a "$sameMAC" -eq 0 ]; then
            br_mac=$(ifconfig eth1 | grep HWaddr | awk '{print $5}')
        fi

        # Wifi Interface should be up by now
        if [ "$i" = "Two" -a "$sameMAC" -eq 0 ]; then
            br_mac=$(uci show wireless | grep macaddr | grep wifi0 | cut -d '=' -f2 |
                         sed 's/^.\(.*\).$/\1/')
        fi

        if [ "$i" = "Three" -a "$sameMAC" -eq 0 ]; then
            br_mac=$(uci show wireless | grep macaddr | grep wifi1 | cut -d '=' -f2 |
                         sed 's/^.\(.*\).$/\1/')
        fi

        uci_set network "$nw_name" macaddr $br_mac
        ifconfig br-$nw_name hw ether "$br_mac"
        uci_commit network
        num_vlan=$((num_vlan-1))
    done
}

# Delete all managed VAPs and re-create them according to the current
# configuration.
#
# Unlike the above, this is destructive in that all VAPs not marked as
# repacd_security_unmanaged will be deleted. If this is not desired, set the
# FirstConfigRequired flag to 0 to prevent this step from taking place. In
# this case, the VAPs must be created manually in a manner that matches the
# expectations of this script.
#
# input: $1 - is_controller: whether this device is acting as the controller
__repacd_reset_map_default_config() {
    local is_controller=$1

    local fronthaul_ssid fronthaul_key backhaul_ssid backhaul_key
    local backhaul_suffix smartmonitor_ssid
    local fh_vap_count vlan_id nw_name num_vlan
    local map_r1_sta_assoc_disallow map_r2_sta_assoc_disallow
    local vap_bh_bss_type
    local disable_steer ad_vap_index
    # Default values
    vlan_id=0 map_r1_sta_assoc_disallow=0 map_r2_sta_assoc_disallow=0
    vap_bh_bss_type=$((map_r1_sta_assoc_disallow|map_r2_sta_assoc_disallow))
    fh_vap_count=1 nw_name="lan" disable_steer=0

    config_load repacd
    config_get fronthaul_ssid MAPConfig 'FronthaulSSID' ''
    config_get fronthaul_key MAPConfig 'FronthaulKey' ''
    config_get fronthual_authtype MAPConfig 'FronthaulAuthType' 0
    config_get additional_vaps MAPConfig 'AdditionalFH' ''
    config_get backhaul_ssid MAPConfig 'BackhaulSSID' ''
    config_get backhaul_key MAPConfig 'BackhaulKey' ''
    config_get backhaul_suffix MAPConfig 'BackhaulSuffix' ''
    config_get backhual_authtype MAPConfig 'BackhaulAuthType' 0

    config_get smartmonitor_ssid MAPConfig 'SmartMonitorSSID' 'ap_smart_monitor'

    if [ "$map_version" -gt 1 ]; then
        config_get map_r1_sta_assoc_disallow MAPConfig 'R1AgentAssocDisAllowed' '0'
        config_get map_r2_sta_assoc_disallow MAPConfig 'R2AgentAssocDisAllowed' '0'
        vap_bh_bss_type=$(($((map_r1_sta_assoc_disallow<<3))|$((map_r2_sta_assoc_disallow<<2))))
        if [ "$map_ts_enabled" -gt 0 ]; then
            config_get map_primary_vlan MAPConfig 'VlanIDNwPrimary' '0'
            nw_name=$map_primary_nw
        fi
    fi

    config_load wireless
    config_foreach __repacd_delete_managed_vaps wifi-iface $managed_network
    uci_commit wireless

    # Clear out the environment of all CONFIG_ variables. Seems like there
    # should be some way to do this in UCI.
    unset $(set | grep '^CONFIG_' | awk -F'=' '{print $1}')

    # Reload to reset our variable state after the deletion
    config_load wireless

    if [ -z "$fronthaul_ssid" ]; then
        local ssid_suffix
        __repacd_generate_ssid_suffix ssid_suffix
        fronthaul_ssid="mapsig-${ssid_suffix}"
        __repacd_generate_psk fronthaul_key
    fi

    if [ -z "$backhaul_ssid" ]; then
        backhaul_ssid="${fronthaul_ssid}${backhaul_suffix}"

        if [ "$fronthaul_ssid" = "$backhaul_ssid" ]; then
            backhaul_key=$fronthaul_key
        else
            __repacd_generate_psk backhaul_key
        fi
    fi

    __repacd_create_vaps_map "$is_controller" "$fronthaul_ssid" "$fronthaul_key" \
                             "$backhaul_ssid" "$backhaul_key" "$smartmonitor_ssid" \
                             "$fh_vap_count" "$vap_bh_bss_type" "$map_primary_vlan" "$nw_name" \
                             "$fronthual_authtype" "$backhual_authtype" "$disable_steer"

   disable_steer=1
   ad_vap_index=1
   while [ $ad_vap_index -le $MAP_MAX_ADDITIONA_VAP ]; do
       ad_vap=$(eval "echo $additional_vaps | awk 'BEGIN { FS = \",\" }; { print \$$ad_vap_index }'")
       if [ -z $ad_vap ]; then
          break;
       fi
       fronthaul_ssid=$(eval "echo $ad_vap | awk 'BEGIN { FS = \":\" }; { print \$1 }'")
       fronthaul_key=$(eval "echo $ad_vap | awk 'BEGIN { FS = \":\" }; { print \$2 }'")
       fronthual_authtype=$(eval "echo $ad_vap | awk 'BEGIN { FS = \":\" }; { print \$3 }'")
       ad_vap_index=$((ad_vap_index+1))
       fh_vap_count=$((fh_vap_count+1))
        __repacd_create_vaps_map "$is_controller" "$fronthaul_ssid" "$fronthaul_key" \
                                 "$backhaul_ssid" "$backhaul_key" "$smartmonitor_ssid" \
                                 "$fh_vap_count" "$vap_bh_bss_type" "$map_primary_vlan" "$nw_name" \
                                 "$fronthual_authtype" "$backhual_authtype" "$disable_steer"
    done
    disable_steer=0

    if [ "$map_version" -gt 1 -a "$map_ts_enabled" -gt 0 -a "$is_controller" -gt 0 ]; then
        num_vlan=$num_vlan_supported
        for i in One Two Three; do
            # if 1 then VLAN is configured on Primary VLAN
            if [ "$num_vlan" -eq 0 -o "$num_vlan" -eq 1 ]; then
                break
            fi

            config_get fronthaul_ssid MAPConfig "FronthaulSSIDNw"$i ''
            config_get fronthaul_key MAPConfig "FronthaulKeyNw"$i ''
            config_get fronthual_authtype MAPConfig "FronthaulAuthTypeNw"$i 0
            config_get vlan_id MAPConfig "VlanIDNw"$i '0'
            config_get nw_name MAPConfig "VlanNetwork"$i ''

            if [ -z "$fronthaul_ssid" ]; then
                local ssid_suffix
                __repacd_generate_ssid_suffix ssid_suffix
                fronthaul_ssid="mapsig-${ssid_suffix}-$i"
                __repacd_generate_psk fronthaul_key
            fi

            __repacd_echo "Fronthaul SSID Network $i : $fronthaul_ssid"
            __repacd_echo "Fronthaul Key Network $i : $fronthaul_key"
            __repacd_echo "Fronthaul AuthType $i: $fronthual_authtype"
            __repacd_echo "Fronthaul Vlan ID $i : $vlan_id"
            __repacd_echo "Fronthaul Network$i Name : $nw_name"

            fh_vap_count=$((fh_vap_count+1))
            __repacd_create_vaps_map "$is_controller" "$fronthaul_ssid" "$fronthaul_key" \
                                     "$backhaul_ssid" "$backhaul_key" "$smartmonitor_ssid" \
                                     "$fh_vap_count" "$vap_bh_bss_type" "$vlan_id" "$nw_name" \
                                     "$fronthual_authtype" "$backhual_authtype" "$disable_steer"

            num_vlan=$((num_vlan-1))
        done
    fi
}

# Delete all of the VAPs for the given network that are marked as unmanaged.
#
# input: $1 config: section being considered
# input: $2 network: managed network name
__repacd_delete_managed_vaps() {
    local config="$1"
    local network repacd_security_unmanaged mode
    local vlan_nw_name backhaul_nw_name

    config_get network "$config" network
    config_get mode "$config" mode
    config_get_bool repacd_security_unmanaged "$config" repacd_security_unmanaged '0'

    if [ "$2" = "$network" ] && [ "$repacd_security_unmanaged" -eq 0 ]; then
        uci delete "wireless.$config"
    fi

    if [ $mode = "ap_smart_monitor" ]; then
        uci delete "wireless.$config"
    fi

    if [ "$map_version" -gt 1 ]; then
        for i in One Two Three; do
            config_get vlan_nw_name MAPConfig "VlanNetwork"$i ''
            if [ "$vlan_nw_name" = "$network" ] && [ "$repacd_security_unmanaged" -eq 0 ]; then
                uci delete "wireless.$config"
            fi
        done

        config_get backhaul_nw_name MAPConfig "VlanNetworkBackHaul" ''
        if [ "$backhaul_nw_name" = "$network" ] && [ "$repacd_security_unmanaged" -eq 0 ]; then
            uci delete "wireless.$config"
        fi
    fi
}

# For Traffic Separation on EasyMesh Device we do not support combined
# Profile-1 and Profile-2 backhaul. Check if Profile-1 or Profile-2 STA
# Assoc is DisAllowed and create backHaul BSS accordingly.

# If Profile-1 Assoc is DisAllowed create 1 backhaul BSS and update MapBSSType
# for Profiel-1 Assoc DisAllowed
# If Profile-2 Assoc is DisAllowed create 1 backhaul BSS and update MapBSSType
# for Profiel-2 Assoc DisAllowed
# If both Profile-1 and Profile-2 Assoc is allowed then create 2 backhaul BSS
# Mark one as Profile-1 Assoc Disallowed and the other as Profile-2 Assoc DisAllowed
# If Fronthaul and backHaul are on the same VAP then split such a VAP to 1 frontaul
# and 2 backhaul VAP with above configuration
#
# input: $1 name: Current VAP config
# input: $2 device: the radio to which the VAP belongs
# input: $3 backhaul_ssid: the SSID to use on all backhaul VAPs
# input: $4 backhaul_key: the PSK for the backhaul, or the empty string
#                         for open mode
# input: $5 encryption: encryption
# input: $6 vap_bss_type: current vap attribute
# input: $7 vap_bh_bss_type: carries backhaul BSS attribute
# input: $8 backhual_authtype: backhaul authentication type
__reapcd_create_additional_backhaul_map() {
    local name=$1
    local device=$2
    local backhaul_ssid=$3
    local backhaul_key=$4
    local backhaul_encryption=$5
    local vap_bss_type=$6
    local vap_bh_bss_type=$7
    local backhual_authtype=$8

    local bss_attribute

    # Split shared vap into 1 FH and 2 BH VAPs
    if [ "$vap_bss_type" -eq 96 ]; then
        # Mark VAP as fronthaul
        __repacd_update_vap_param "$name" 'MapBSSType' 32
        __repacd_update_vap_param "$name" 'network' $map_primary_nw

        # Add new backhaul VAP
        name=$(uci add wireless wifi-iface)
        config_changed=1

        __repacd_init_vap "$name" $device 'ap' "$backhaul_ssid" \
                          $backhaul_encryption "$backhaul_key" '0'
        __repacd_update_vap_param "$name" 'map' 1
        __repacd_update_vap_param "$name" 'MapBSSType' 64
        __repacd_update_vap_param "$name" 'wps_pbc' 0

        if [ $backhual_authtype -gt 0 ]; then
            __repacd_update_vap_param "$name" 'sae' 1
        fi
    fi

    # update backhaul BSS based on DisAllow Bit
    if [ "$vap_bh_bss_type" -eq 8 ]; then
        # vap_bh_bss_type 8, Profile-1 Backhaul STA association disallowed
        bss_attribute=$((vap_bh_bss_type|64))
        __repacd_update_vap_param "$name" 'MapBSSType' $bss_attribute
        if [ "$map_primary_vlan" -gt 0 ]; then
            __repacd_update_vap_param "$name" 'network' $map_backhaul_nw
            __repacd_update_vap_param "$name" 'map8021qvlan' $map_primary_vlan
            __repacd_update_vap_param "$name" 'vlan_bridge' "br-$map_primary_nw"
        fi
    elif [ "$vap_bh_bss_type" -eq 4 ]; then
        # vap_bh_bss_type 4, Profile-2 Backhaul STA association disallowed
        bss_attribute=$((vap_bh_bss_type|64))
        __repacd_update_vap_param "$name" 'MapBSSType' $bss_attribute
        __repacd_update_vap_param "$name" 'network' $map_primary_nw

        # Disable the SAE authentication for R1 Agent BH BSS
        if [ $backhual_authtype -eq 1 ]; then
            __repacd_update_vap_param "$name" 'sae' 0
            __repacd_update_vap_param "$name" 'encryption' "psk2+ccmp"
        fi

        if [ "$map_primary_vlan" -gt 0 ]; then
            __repacd_update_vap_param "$name" 'map8021qvlan' $map_primary_vlan
        fi
    elif [ "$vap_bh_bss_type" -eq 0 ]; then
        if [ "$vap_bss_type" -eq 96 -a "$map_single_r1r2_bh" -eq 1 -a "$vlan_id" -gt 0 ]; then
            __repacd_update_vap_param "$name" 'network' $map_backhaul_nw
            __repacd_update_vap_param "$name" 'map8021qvlan' $map_primary_vlan
            __repacd_update_vap_param "$name" 'vlan_bridge' "br-$map_primary_nw"
            return
        fi

        # Update current bhBSS for r2 Agent assoc disallowed
        bss_attribute=$((vap_bh_bss_type|64|4))
        __repacd_update_vap_param "$name" 'MapBSSType' $bss_attribute
        __repacd_update_vap_param "$name" 'network' $map_primary_nw

        # Disable the SAE authentication for R1 Agent BH BSS
        if [ $backhual_authtype -eq 1 ]; then
            __repacd_update_vap_param "$name" 'sae' 0
            __repacd_update_vap_param "$name" 'encryption' "psk2+ccmp"
        fi

        # Create One More bhBSS for r2 Agents
        name=$(uci add wireless wifi-iface)
        config_changed=1

        __repacd_init_vap "$name" $device 'ap' "$backhaul_ssid" \
                          $backhaul_encryption "$backhaul_key" '0'
        __repacd_update_vap_param "$name" 'map' 2
        # Update current bhBSS for r1 Agent assoc disallowed
        bss_attribute=$((vap_bh_bss_type|64|8))
        __repacd_update_vap_param "$name" 'MapBSSType' $bss_attribute
        __repacd_update_vap_param "$name" 'wps_pbc' 0
        if [ "$map_primary_vlan" -gt 0 ]; then
            __repacd_update_vap_param "$name" 'network' $map_backhaul_nw
            __repacd_update_vap_param "$name" 'map8021qvlan' $map_primary_vlan
            __repacd_update_vap_param "$name" 'vlan_bridge' "br-$map_primary_nw"
        fi

        if [ $backhual_authtype -eq 1 ]; then
            __repacd_update_vap_param "$name" 'sae' 1
        fi

    fi
}

# Create the VAPs needed for Multi-AP SIG Topology Optimization with them all
# initially disabled.
#
# input: $1 is_controller: whether this device is acting as the controller
# input: $2 fronthaul_ssid: the SSID to use on all fronthaul VAPs
# input: $3 fronthaul_key: the PSK for the fronthaul, or the empty string
#                          for open mode
# input: $4 backhaul_ssid: the SSID to use on all backhaul VAPs
# input: $5 backhaul_key: the PSK for the backhaul, or the empty string
#                         for open mode
# input: $6 smartmonitor_ssid: the SSID to use on all smart monitor VAPs
# input: $7 fh_vap_count: the count of Fronthaul VAPs that are created on a radio
# input: $8 vap_bh_bss_type: carries backhaul BSS attribute
# input: $9 vlan_id: fronthaul vlan ID
# input: $10 nw_name: network to which the fronthaul belongs to
# input: $11 fronthaul_authtype: the authentication type used for fronthaul
# input: $12 backhaul_authtype: the authentication type used for backhaul
__repacd_create_vaps_map() {
    local is_controller=$1
    local fronthaul_ssid=$2
    local fronthaul_key=$3
    local backhaul_ssid=$4
    local backhaul_key=$5
    local smartmonitor_ssid=$6
    local fh_vap_count=$7
    local vap_bh_bss_type=$8
    local vlan_id=$9
    local nw_name=$10
    local fronthaul_authtype=$11
    local backhaul_authtype=$12
    local disable_steer=$13

    local fronthaul_encryption backhaul_encryption
    local smartmonitor_encryption='none'
    local enable_smart_monitor_mode
    local bss_attribute

    # Whether the same VAP is used for fronthaul and backhaul or not.
    local shared_vaps=0
    if [ "$fronthaul_ssid" = "$backhaul_ssid" ]; then
        shared_vaps=1
    fi

    if [ -n "$fronthaul_key" ]; then
        fronthaul_encryption='psk2+ccmp'
    else
        fronthaul_encryption='none'
    fi

    if [ -n "$backhaul_key" ]; then
        backhaul_encryption='psk2+ccmp'
        #Enable SAE only mode for pure bakchaul BSS
        if [ "$map_version" -gt 1 ] && [ "$is_controller" -gt 0 ] && \
              [ "$shared_vaps" -eq 0 ] && [ "$backhual_authtype" -eq 1 ]; then
            backhaul_encryption='ccmp'
        fi
    else
        backhaul_encryption='none'
    fi

    local DEVICES=
    __repacd_get_devices DEVICES

    for device in $DEVICES; do
        local repacd_auto_create_vaps repacd_create_bsta repacd_bsta_pref
        local create_ctrl_fbss create_ctrl_bbss neighbourfilter set_monrxfilter
        local disable wsplcd_unmanaged repacd_security_unmanaged
        local no_vlan_val
        config_get_bool repacd_auto_create_vaps "$device" repacd_auto_create_vaps '1'
        config_get_bool repacd_create_bsta "$device" repacd_create_bsta '1'
        config_get repacd_bsta_pref "$device" repacd_map_bsta_preference '0'
        config_get_bool create_ctrl_fbss "$device" repacd_create_ctrl_fbss '1'
        config_get_bool create_ctrl_bbss "$device" repacd_create_ctrl_bbss '1'
        uci_set wireless $device disabled '0'

        if [ "$map_version" -gt 1 -a "$map_ts_enabled" -gt 0 ]; then
            config_get no_vlan_val $device no_vlan '0'
            if [ "$no_vlan_val" -eq 0 ]; then
                uci_set wireless $device no_vlan '1'
            fi
        fi

        # Create one bSTA per radio
        if [ "$fh_vap_count" -eq 1 ] && [ "$repacd_auto_create_vaps" -gt 0 ] && \
               [ "$repacd_create_bsta" -gt 0 ] && ! whc_is_5g_radio "$device"; then
            # Create a bSTA interface
            name=$(uci add wireless wifi-iface)
            config_changed=1

            __repacd_init_vap "$name" $device 'sta' "$backhaul_ssid" \
                              $backhaul_encryption "$backhaul_key" '0'
            __repacd_update_vap_param "$name" 'map' 1
            __repacd_update_vap_param "$name" 'MapBSSType' 128
            __repacd_update_vap_param "$name" 'wps_state' 1
            __repacd_update_vap_param "$name" 'wps_pbc_skip' 1
            if [ "$map_dpp_enabled" -eq 1 ]; then
                __repacd_update_vap_param "$name" 'dpp' 1
                __repacd_update_vap_param "$name" 'dpp_map' 1
            fi

            # Enable 802.11k support so that the controller can ask for
            # beacon measurements from the bSTA
            __repacd_update_vap_param "$name" 'rrm' 1
            __repacd_update_vap_param "$name" 'rrm_capie' 1

            # update network name if traffic separation is enabled
            if [ "$map_version" -gt 1 ]; then
                __repacd_update_vap_param "$name" 'map' $map_version
                __repacd_update_vap_param "$name" 'network' $map_primary_nw
                if [ "$map_ts_enabled" -gt 0 -a "$is_controller" -eq 1 -a "$vlan_id" -gt 0 ]; then
                    __repacd_update_vap_param "$name" 'network' $map_backhaul_nw
                fi
            fi

            # For initial onboarding, 2.4 GHz is the selected bSTA radio
            # (unless it is given a preference value of 0, in which case
            # no radio is marked as selected and we let the preference values
            # determine it entirely).
            if whc_is_5g_vap "$name" || [ "$repacd_bsta_pref" -eq 0 ]; then
                uci_set wireless $device repacd_map_bsta_selected '0'
            else
                uci_set wireless $device repacd_map_bsta_selected '1'
            fi
        fi

        # If not acting as the controller, we will let the Multi-AP
        # Configuration procedure create the BSSes. However, due to
        # limitations in wsplcd, we have to create a BSS on each radio to
        # ensure AP Auto-Config takes place. If this is removed, then repacd
        # can be updated to only do this on the controller again.
        if [ "$repacd_auto_create_vaps" -gt 0 ]; then
            # Only create the fBSS on agents (to ensure wsplcd works) or on
            # the controller if so configured.
            if [ "$is_controller" -eq 0 ] || [ "$create_ctrl_fbss" -gt 0 ]; then
                # Create the fBSS (which may also be a bBSS)
                name=$(uci add wireless wifi-iface)
                config_changed=1

                __repacd_init_vap "$name" $device 'ap' "$fronthaul_ssid" \
                                  $fronthaul_encryption "$fronthaul_key" '0'
                __repacd_update_vap_param "$name" 'map' 1

                if [ "$disable_steer" -gt 0 ]; then
                     __repacd_update_vap_param "$name" 'SteeringDisabled' 1
                fi

                if [ "$map_version" -gt 1 ]; then
                    __repacd_update_vap_param "$name" 'map' $map_version
                    __repacd_update_vap_param "$name" 'network' $map_primary_nw

                    if [ "$is_controller" -gt 0 ] && [ "$fronthual_authtype" -gt 0 ]; then
                        __repacd_update_vap_param "$name" 'sae' 1
                    fi

                    # Enable wps_pbc only on one fronthaul
                    if [ "$fh_vap_count" -gt 1 ]; then
                        __repacd_update_vap_param "$name" 'wps_pbc' 0
                    fi

                    if [ "$map_ts_enabled" -gt 0 -a "$is_controller" -eq 1 ]; then
                        __repacd_update_vap_param "$name" 'network' $nw_name
                        __repacd_update_vap_param "$name" 'mapVlanID' $vlan_id
                        __repacd_update_vap_param "$name" 'map8021qvlan' $map_primary_vlan
                    fi

                    if [ "$map_dpp_enabled" -eq 1 ]; then
                        __repacd_update_vap_param "$name" 'dpp_map' 1
                        __repacd_update_vap_param "$name" 'dpp_configurator_connectivity' 1
                    fi
                fi

                if [ "$shared_vaps" -gt 0 ]; then
                    # fBSS uses same VAP as bBSS
                    __repacd_update_vap_param "$name" 'MapBSSType' 96
                    if [ "$map_ts_enabled" -gt 0 -a "$is_controller" -eq 1 ]; then
                        __reapcd_create_additional_backhaul_map "$name" "$device" \
                                                                "$fronthaul_ssid" "$fronthaul_key" \
                                                                "$fronthaul_encryption" "96" \
                                                                "$vap_bh_bss_type" "$fronthual_authtype"
                    fi
                else
                    # Distinct VAPs for backhaul and fronthaul
                    __repacd_update_vap_param "$name" 'MapBSSType' 32
                fi

                # Create smart monitor VAP per each radio on the agent and for
                # every fronthaul BSS on the controller
                # Check if smart monitor mode is enabled
                config_load 'repacd'
                config_get_bool enable_smart_monitor_mode MAPConfig 'EnableSmartMonitorMode' '0'
                if [ "$enable_smart_monitor_mode" -eq 1 ] && [ "$fh_vap_count" -eq 1 ]; then
                    name=$(uci add wireless wifi-iface)
                    config_changed=1

                    __repacd_init_vap "$name" $device 'ap_smart_monitor' "$smartmonitor_ssid" \
                                       $smartmonitor_encryption '0'
                    __repacd_update_vap_param "$name" 'neighbourfilter' 1
                    __repacd_update_vap_param "$name" 'set_monrxfilter' 1
                    __repacd_update_vap_param "$name" 'disable' 0
                    __repacd_update_vap_param "$name" 'wsplcd_unmanaged' 1
                    __repacd_update_vap_param "$name" 'repacd_security_unmanaged' 1
                    __repacd_update_vap_param "$name" 'wps_pbc' 0
                fi
            fi

            # Now create the bBSS, but only on the controller if configured (and
            # only if it is meant to be a unique BSS). The agent will have any
            # bBSSes created via the AP Auto-Configuration process.
            if [ "$is_controller" -gt 0 ] && [ "$create_ctrl_bbss" -gt 0 ] && \
                [ "$shared_vaps" -eq 0 ] && [ "$fh_vap_count" -eq 1 ]; then
                name=$(uci add wireless wifi-iface)
                config_changed=1

                __repacd_init_vap "$name" $device 'ap' "$backhaul_ssid" \
                                  $backhaul_encryption "$backhaul_key" '0'
                __repacd_update_vap_param "$name" 'map' 1
                __repacd_update_vap_param "$name" 'MapBSSType' 64
                # Need to force this disabled per the Multi-AP SIG spec
                __repacd_update_vap_param "$name" 'wps_pbc' 0

                if [ "$map_version" -gt 1 ]; then
                    __repacd_update_vap_param "$name" 'map' $map_version
                    __repacd_update_vap_param "$name" 'network' $map_primary_nw

                    if [ "$map_dpp_enabled" -eq 1 ]; then
                        __repacd_update_vap_param "$name" 'dpp_map' 1
                        __repacd_update_vap_param "$name" 'dpp_configurator_connectivity' 1
                    fi

                    if [ $backhual_authtype -eq 1 ]; then
                        __repacd_update_vap_param "$name" 'sae' 1
                    fi

                    if [ "$map_ts_enabled" -gt 0 -a "$vlan_id" -gt 0 ]; then
                        if [ "$map_single_r1r2_bh" -eq 1 ]; then
                            bss_attribute=$((vap_bh_bss_type|64))
                            __repacd_update_vap_param "$name" 'MapBSSType' $bss_attribute
                            if [ "$map_primary_vlan" -gt 0 ]; then
                                __repacd_update_vap_param "$name" 'network' $map_backhaul_nw
                                __repacd_update_vap_param "$name" 'map8021qvlan' $map_primary_vlan
                                __repacd_update_vap_param "$name" 'vlan_bridge' "br-$map_primary_nw"
                            fi
                        else
                            __reapcd_create_additional_backhaul_map "$name" "$device" \
                                                                    "$backhaul_ssid" "$backhaul_key" \
                                                                    "$backhaul_encryption" "64" \
                                                                    "$vap_bh_bss_type" "$backhual_authtype"
                        fi
                    fi
                fi
            fi
        fi
    done
    uci_commit wireless
}

# Enumerate all of the devices and append them to the variable provided.
# input: $1 devices: variable to populate with the devices
__repacd_get_devices() {
    local devices=$1

    config_cb() {
        local type="$1"
        local section="$2"

        case "$type" in
            wifi-device)
		config_get hwmode "$section" hwmode
		config_get type "$section" type
		if [ "$type" != 'mac80211' ] && [ "$hwmode" != '11ad' ];then
		    eval append $devices "$section"
		fi
                ;;
        esac
    }
    config_load wireless
}

# Enable all Wi-Fi devices
__repacd_enable_wifi() {
    local DEVICES=
    local device changed=0

    __repacd_get_devices DEVICES

    for device in $DEVICES; do
        config_get_bool disabled $device disabled
        [ -z "$disabled" ] && continue
        [ "$disabled" -eq 0 ] && continue

        uci_set wireless $device disabled '0'
        changed=1
    done

    if [ "$changed" -gt 0 ]; then
        uci_commit wireless
        config_changed=1
    fi
}

# Set the parameter in the wireless configuration section provided, recording
# if it actually needed to be changed.
# input: $1 iface_name: section name
# input: $2 param_name: the name of the parameter being set
# input: $3 param_val: the new value for the parameter
__repacd_update_vap_param() {
    local iface_name=$1 param_name=$2 param_val=$3
    local cur_val

    config_get cur_val "$iface_name" "$param_name"
    if [ -z "$cur_val" ] || [ ! "$cur_val" = "$param_val" ]; then
        uci_set wireless "$iface_name" "$param_name" "$param_val"
        config_changed=1
    fi
}

# Determine the SSID to apply to a specific VAP based on the current
# configuration of the WPS Push Button Configuration enhancement.
# input: $1 name: section name
# input: $2 device: name of the radio
# input: $3 base_ssid: the SSID from which to derive other ones
# input: $4 vap_count: additional vap count created in Device
__repacd_init_vap_set_ssid_and_pbc() {
    local name=$1 device=$2 base_ssid=$3 vap_count=$4
    local mode
    local enable_wps_re_enhc global_suffix='' radio_suffix=''
    local start_time duration
    local auto_create_vaps

    # Grab the overall enable first
    config_get enable_wps_re_enhc qcawifi wps_pbc_extender_enhance '0'

    # Now VAP specific parameters
    config_get mode "$name" mode
    config_get start_time "$name" wps_pbc_start_time
    config_get duration "$name" wps_pbc_duration
    config_get_bool repacd_security_unmanaged  "$name" repacd_security_unmanaged '0'
    config_get_bool auto_create_vaps "$device" repacd_auto_create_vaps '1'

    if [ "$enable_wps_re_enhc" -gt 0 ]; then
        # Only apply the SSID derivation rules on AP interfaces.
        if __repacd_is_matching_mode 'ap' $mode; then
            # Potentially two suffixes can be applied
            # First is set at the overall AP level.
            config_get global_suffix qcawifi wps_pbc_overwrite_ssid_suffix ''

            # Second is set at the radio level
            config_get radio_suffix "$device" wps_pbc_overwrite_ssid_band_suffix ''
        fi
    fi

    if [ "$repacd_security_unmanaged" -eq 0 ] ; then
        __repacd_update_vap_param "$name" 'ssid' "$base_ssid$global_suffix$radio_suffix"
    fi

    #Disabling WPS for all additional FH VAPs
    if [ "$vap_count" -eq 0 ]; then
        __repacd_update_vap_param "$name" 'wps_pbc' 1
        __repacd_update_vap_param "$name" 'wps_pbc_enable' "$enable_wps_re_enhc"
        if [ "$traffic_separation_enabled" -gt 0 ]; then
            __repacd_update_vap_param "$name" 'wps_pbc_noclone' '1'
        fi

        # Without a custom config, set all interfaces to be enabled for 2 minutes.
        if [ -z "$start_time" ]; then
            __repacd_update_vap_param "$name" 'wps_pbc_start_time' 0
        fi

        if [ -z "$duration" ]; then
            if [ "$traffic_separation_enabled" -gt 0 ] && [ "$auto_create_vaps" -eq 1 ]; then
                __repacd_update_vap_param "$name" 'wps_pbc_duration' 60
            else
                __repacd_update_vap_param "$name" 'wps_pbc_duration' 120
            fi
        fi
    fi
}

# Set all of the configuration parameters for the given VAP.
# input: $1 name: section name
# input: $2 device: name of the radio
# input: $3 mode: whether to act as a STA or AP
# input: $4 ssid: the desired SSID for this VAP
# input: $5 encryption: the desired encryption mode for this VAP
# input: $6 key: the desired passphrase for this VAP
# input: $7 vap_count: additional vap count created in Device
__repacd_init_vap() {
    local name=$1 device=$2 mode=$3 ssid=$4 encryption=$5 key=$6 vap_count=$7
    local cur_mode

    config_get_bool repacd_security_unmanaged "$name" repacd_security_unmanaged '0'
    __repacd_update_vap_param "$name" 'device' "$device"
    __repacd_update_vap_param "$name" 'network' $managed_network
    __repacd_init_vap_set_ssid_and_pbc "$name" "$device" "$ssid" "$vap_count"

    if [ "$repacd_security_unmanaged" -eq 0 ] ; then
        __repacd_update_vap_param "$name" 'encryption' "$encryption"
        __repacd_update_vap_param "$name" 'key' "$key"
    fi

    # Mode needs to be handled separately. If the device is already in one
    # of the AP modes and the init is requesting an AP mode, we leave it as
    # is. If it is already in the STA mode, we also leave it as is.
    config_get cur_mode "$name" 'mode'
    if ! __repacd_is_matching_mode "$mode" "$cur_mode"; then
        uci_set wireless "$name" 'mode' "$mode"
        config_changed=1
    fi
}

# Initialise all the additional that we created to support multi ssid traffic
# separation.
# input: $1 name: section name
# input: $2 device: name of the radio
# input: $3 mode: whether to act as a STA or AP
# input: $4 hwmode: radio hardware mode
# input: $5 network: desired network for this VAP
# input: $6 ssid: the desired SSID for this VAP
# input: $7 encryption: the desired encryption mode for this VAP
# input: $8 key: the desired passphrase for this VAP
__repacd_init_additional_vap() {
    local name=$1 device=$2 mode=$3 hwmode=$4 network=$5
    local ssid=$6 encryption=$7 key=$8
    local cur_mode repacd_security_unmanaged auto_create_vaps
    local enable_wds enable_rrm enable_qwrap_ap enable_extap block_dfs
    local rate_scaling_factor=0
    local num_changes=0
    local cur_key

    __repacd_update_vap_param "$name" 'device' "$device"
    __repacd_update_vap_param "$name" 'network' "$network"

    config_get_bool repacd_security_unmanaged  "$name" repacd_security_unmanaged '0'
    if [ "$repacd_security_unmanaged" -eq 0 ] ; then
        __repacd_update_vap_param "$name" 'ssid' "$ssid"
        __repacd_update_vap_param "$name" 'encryption' "$encryption"

        config_get cur_key "$name" 'key'
        if [ ! "$cur_key" = "$key" ]; then
            __repacd_update_vap_param "$name" 'key' "$key"
        fi
    fi

    # using SON mode related settings to config backhaul VAPs.
    config_get_bool auto_create_vaps "$device" repacd_auto_create_vaps '1'
    if [ "$network" = "$network_backhaul" ] && [ "$auto_create_vaps" -eq 1 ]; then
        __repacd_update_vap_param "$name" 'wps_pbc_noclone' '0'
        __repacd_update_vap_param "$name" 'wps_pbc_enable' '1'
        __repacd_update_vap_param "$name" 'wps_pbc' '1'
        __repacd_update_vap_param "$name" 'wps_pbc_start_time' '61'
        __repacd_update_vap_param "$name" 'wps_pbc_duration' '120'
        __repacd_update_vap_param "$name" 'wds' '1'
        __repacd_update_vap_param "$name" 'extap' '0'
        config_load $MAP
        config_get hyfi_mode 'config' 'Mode' 'HYROUTER'
        if [ "$hyfi_mode" = "HYCLIENT" ]; then
            __repacd_update_vap_param "$name" 'root_distance' '255'
        fi
        if __repacd_is_matching_mode 'ap' "$mode"; then
            __repacd_update_vap_param "$name" 'qwrap_ap' '0'
            __repacd_update_vap_param "$name" 'rrm' '1'
            __repacd_update_vap_param "$name" 'hidden' '0'
            if __repacd_is_block_dfs; then
                __repacd_update_vap_param "$name" 'blockdfschan' '1'
            else
                __repacd_update_vap_param "$name" 'blockdfschan' '0'
            fi
        fi
    else
        __repacd_echo "Auto create VAPs disabled"
    fi
    if [ "$network" = "$network_guest" ] && [ "$auto_create_vaps" -eq 1 ]; then
        __repacd_update_vap_param "$name" 'rrm' '1'
    fi

    # Mode needs to be handled separately. If the device is already in one
    # of the AP modes and the init is requesting an AP mode, we leave it as
    # is. If it is already in the STA mode, we also leave it as is.
    config_get cur_mode "$name" 'mode'
    if ! __repacd_is_matching_mode "$mode" "$cur_mode"; then
        uci_set wireless "$name" 'mode' "$mode"
        config_changed=1
    fi
}

# Create the 4 VAPs needed (1 STA and 1 AP for each radio), with them all
# initially disabled. Three radio platforms are not currently handled.
#
# Note that if the VAPs already exist, they will be reconfigured as
# appropriate. Existing VAP section names are given by ${device}_ap and
# ${device}_sta global variables.
#
# input: $1 ssid: the SSID to use on all VAPs
# input: $2 encryption: the encryption mode to use on all VAPs
# input: $3 key: the pre-shared key to use on all VAPs
__repacd_create_vaps() {
    local ssid=$1
    local encryption=$2
    local key=$3
    local DEVICES=
    local backhaul_selected=0
    local additional_fh

    config_load $MAP
    config_load repacd

    config_get hyfi_mode 'config' 'Mode' 'HYROUTER'
    config_get additional_fh repacd 'AdditionalFHCount' '0'

    __repacd_get_devices DEVICES

    for device in $DEVICES; do
        local addi_vap=0
        if whc_is_5g_radio $device && [ "$backhaul_selected" -eq 0 ]; then
            # 5 GHz and we do not have a backhaul interface yet, so select
            # this one as the backhaul interface.
            #
            # @todo Consider which 5 GHz radio should be used for backhaul if
            #       there is more than one.
            backhaul_selected=1
        fi

        config_get_bool repacd_auto_create_vaps "$device" repacd_auto_create_vaps '1'
        uci_set wireless $device disabled '0'

        local name
        name=$(eval "echo \$${device}_ap")
        if [ -z "$name" ] && [ "$repacd_auto_create_vaps" -eq 1 ]; then
            # No existing entry; create a new one.
            name=$(uci add wireless wifi-iface)
            config_changed=1
        fi

        if [ -n "$name" ]; then
            # In case of auto config, this will be the fronthaul+backhaul AP VAP
            # However in manual config, this can be the fronthaul VAP
            # In manual cofig user sets this flag
            # We use repacd_auto_create_vaps to distinguish the two cases
            if [ "$repacd_auto_create_vaps" -eq 1 ]; then
                uci_set wireless "$name" backhaul_ap '1'
            fi

            __repacd_init_vap "$name" $device 'ap' "$ssid" "$encryption" "$key" "$addi_vap"
        fi

        addi_vap=1
        while [ $addi_vap -le $additional_fh ]; do
            name=$(eval "echo \$${device}_ap${addi_vap}")
            if [ -z "$name" ] && [ "$repacd_auto_create_vaps" -eq 1 ]; then
                # No existing entry; create a new one.
                name=$(uci add wireless wifi-iface)
                config_changed=1
                __repacd_init_vap "$name" $device 'ap' "${ssid}_${addi_vap}" "$encryption" "$key" "$addi_vap"
                __repacd_update_vap_param "$name" 'SteeringDisabled' 1
            fi
        addi_vap=$((addi_vap+1));
        done

        name=$(eval "echo \$${device}_sta")
        if [ -z "$name" ] && [ "$repacd_auto_create_vaps" -eq 1 ] && \
           [ "$traffic_separation_active" -eq 0 ] && [ "$hyfi_mode" = "HYCLIENT" ]; then
            # No existing entry; create a new one.
            name=$(uci add wireless wifi-iface)
            config_changed=1
        fi

        if [ -n "$name" ] && [ "$hyfi_mode" = "HYCLIENT" ]; then
            __repacd_init_vap "$name" $device 'sta' "$ssid" "$encryption" "$key" '0'
        fi
    done
    uci_commit wireless
}

# Create the additional vaps required for multi ssid traffic separation.
# 1 guest vap and 1 spcl vap on each radio. Currently no sta vaps created.
# spcl vap on 2.4GHz band will be disabled.
# Note that if the VAPs already exist, they will be reconfigured as
# appropriate. Existing VAP section names are given by
# ${device}_(backhaul/guest)_ap and
# ${device}_(backhaul/guest)_sta global variables.
#
# input: $1 network: network to which this vap belongs
# input: $2 ssid: the SSID to use on all VAPs for the provided network
# input: $3 encryption: the encryption mode to use on all VAPs
# input: $4 key: the pre-shared key to use on all VAPs
__repacd_create_additional_vaps() {
    local ssid=$2
    local encryption=$3
    local key=$4
    local network=$1
    local DEVICES=
    local no_vlan_val
    local hwmode marker

    if [ "$network" = "$network_backhaul" ]; then
        marker="backhaul"
    elif [ "$network" = "$network_guest" ]; then
        marker="guest"
    fi

    __repacd_get_devices DEVICES

    for device in $DEVICES; do
        config_get_bool repacd_auto_create_vaps "$device" repacd_auto_create_vaps '1'
        uci_set wireless $device disabled '0'
        config_get hwmode $device hwmode
        config_get no_vlan_val $device no_vlan '0'
        if [ "$no_vlan_val" -eq 0 ]; then
            uci_set wireless $device no_vlan '1'
        fi

        local name_managed
        name_managed=$(eval "echo \$${device}_ap")
        local name
        name=$(eval "echo \$${device}_${marker}_ap")
        if [ -z "$name" ] && [ "$repacd_auto_create_vaps" -eq 1 ]; then
            # No existing entry; create a new ap.
            name=$(uci add wireless wifi-iface)
            config_changed=1
        fi

        if [ -n "$name" ]; then
            if [ "$network" = "$network_backhaul" ]; then
                uci_set wireless "$name" rept_spl '1'
                if [ "$repacd_auto_create_vaps" -eq 1 ]; then
                    uci_set wireless "$name" backhaul_ap '1'
                fi

                if [ -n "$name_managed" ]; then
                    uci_set wireless "$name"_managed backhaul_ap '0'
                fi
            fi

            __repacd_init_additional_vap "$name" $device 'ap' "$hwmode" "$network" \
                                        "$ssid" "$encryption" "$key"
        fi

        if [ $create_sta -eq 1 ]; then
            name=$(eval "echo \$${device}_${marker}_sta")
            if [ -z "$name" ] && [ "$repacd_auto_create_vaps" -eq 1 ]; then
                # No existing entry; create a new sta.
                name=$(uci add wireless wifi-iface)
                config_changed=1
            fi

            if [ -n "$name" ]; then
                __repacd_init_additional_vap "$name" $device 'sta' "$hwmode" "$network" \
                                            "$ssid" "$encryption" "$key"
            fi
        fi
    done
    uci_commit wireless
}

# Reconfigure the STA vaps of managed network.
# After restarting in Non CAP mode we reconfigure the sta vaps
# to be part of backhaul network. Network,ssid and credential
# are changed other configuration remains same.
#
# input: $1 config: section name
# input: $2 : current network
# input: $3 : backhaul network
# input: $4 ssid_val: backhaul ssid
# input: $5 enc_val: backhaul encryption
# input: $6 key_val: backhaul key
__repacd_reconfig_sta_vaps() {
    local config=$1
    local network
    local ssid_val="$4"
    local enc_val="$5"
    local key_val="$6"

    config_get network "$config" network
    if [ "$2" = "$network" ] || [ "$3" = "$network" ]; then
        local mode device hwmode type_val disabled

        config_get mode "$config" mode
        config_get device "$config" device
        config_get hwmode "$device" hwmode
        config_get type_val "$device" type
        config_get disabled "$config" disabled 0

        if [ "$hwmode" = '11ad' ] && [ "$type_val" = 'mac80211' ] ;then
            return
        fi

        if [ "$mode" = "sta" ]; then
            uci_set wireless "$config" rept_spl '1'
            __repacd_init_additional_vap "$config" $device 'sta' "$hwmode" "$3" \
                                            "$ssid_val" "$enc_val" "$key_val"
        fi
    fi
}

# Determine if the mode on the interface is a match.
# This does fuzzy matching in that multiple actual modes are said to match
# a given general mode.
#
# input: $1 general_mode: one of 'sta' or 'ap'
# input: $2 cur_mode: the currently configured mode
# return: 0 on a match; otherwise non-zero
__repacd_is_matching_mode() {
    local general_mode=$1
    local cur_mode=$2

    if [ "$general_mode" = 'sta' ]; then
        if [ "$cur_mode" = 'sta' ]; then
            return 0
        else
            return 1
        fi
    else
        if [ "$cur_mode" = 'ap' ] || [ "$cur_mode" = 'wrap' ]; then
            return 0
        else
            return 1
        fi
    fi
}

# Detect which VAPs are already configured and their corresponding SSID and
# passphrase.
#
# input: $1 config: section name
# input: $2 network: network for which to update VAPs
#
# Updates $resolved_ssid, $resolved_enc, and $resolved_key as appropriate.
__repacd_resolve_vaps() {
    local config="$1"
    local network
    local find_additional_ap=1
    local additional_fh

    config_load repacd
    config_get network "$config" network
    config_get additional_fh repacd 'AdditionalFHCount' '0'

    if [ "$2" = "$network" ]; then
        local device mode ssid_val encryption_val key_val

        config_get device "$config" device
        config_get mode "$config" mode
        config_get ssid_val "$config" ssid
        config_get encryption_val "$config" encryption
        config_get key_val "$config" key
        config_get disabled "$config" disabled 0
        config_get_bool repacd_security_unmanaged "$config" repacd_security_unmanaged '0'
        config_get hwmode "$device" hwmode
        config_get type "$device" type

        if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ] ;then
             return
        fi

        local default_ap
        default_ap=$(eval "echo \$${device}_ap")
        # Remember the section name for this radio in this mode.
        if __repacd_is_matching_mode 'ap' "$mode"; then
            if [ -z "$default_ap" ]; then
                eval "${device}_ap=$config"
                find_additional_ap=0
            fi
        elif [ "$mode" = "sta" ]; then
            eval "${device}_sta=$config"
            find_additional_ap=0
        fi

        if [ "$find_additional_ap" -gt 0 -a "$network" = "$managed_network" ]; then
            addi_vap=1
            while [ $addi_vap -le $additional_fh ]; do
               default_ap=$(eval "echo \$${device}_ap${addi_vap}")
               # Remember the section name for this radio in this mode.
               if __repacd_is_matching_mode 'ap' "$mode"; then
                   if [ -z "$default_ap" ]; then
                       eval "${device}_ap${addi_vap}=$config"
                       break;
                   fi
               fi
               addi_vap=$((addi_vap+1))
            done
        fi

        if [ "$repacd_security_unmanaged" -eq 1 ] ; then
            return
        fi
        # Since there is really no way to know which SSID, encryption mode, or
        # passphrase to use, we will only store the first one unless we come
        # across an enabled STA interface in which case we will prefer that.
        # The reason for this is because if WPS is used without wsplcd, only
        # the STA interface will have the correct SSID and passphrase once the
        # process completes. When switching from pure client mode to RE mode,
        # we want to propagate those values to the AP interfaces and the other
        # STA interface.
        if [ -n "$ssid_val" ] && [ -z "$resolved_ssid" ] || [ "$mode" = "sta" ]; then
            if [ "$disabled" -eq 0 ]; then
                resolved_ssid="$ssid_val"
            fi
        fi

        if [ -n "$encryption_val" ] && [ -z "$resolved_enc" ] || [ "$mode" = "sta" ]; then
            if [ "$disabled" -eq 0 ]; then
                resolved_enc="$encryption_val"
            fi
        fi

        if [ -n "$key_val" ] && [ -z "$resolved_key" ] || [ "$mode" = "sta" ]; then
            if [ "$disabled" -eq 0 ]; then
                resolved_key="$key_val"
            fi
        fi
    fi
}
# Detect which additional VAPs are already configured.
#
# input: $1 config: section name
# input: $2 network: network for which to update VAPs
__repacd_resolve_additional_vaps() {
    local config="$1"
    local network marker

    config_get network "$config" network
    if [ "$2" = "$network" ]; then
        local device mode hwmode type_val encryption_val key_val

        if [ "$network" = "$network_backhaul" ]; then
            marker="backhaul"
        elif [ "$network" = "$network_guest" ]; then
            marker="guest"
        fi

        config_get device "$config" device
        config_get mode "$config" mode
        config_get ssid_val "$config" ssid
        config_get encryption_val "$config" encryption
        config_get key_val "$config" key
        config_get disabled "$config" disabled 0
        config_get hwmode "$device" hwmode
        config_get type_val "$device" type

        if [ "$hwmode" = '11ad' ] && [ "$type_val" = 'mac80211' ] ;then
             return
        fi

        # Remember the section name for this radio in this mode.
        if __repacd_is_matching_mode 'ap' "$mode"; then
            eval "${device}_${marker}_ap=$config"
        elif [ "$mode" = "sta" ]; then
            eval "${device}_${marker}_sta=$config"
        fi

        if [ -n "$ssid_val" ] && [ "$disabled" -eq 0 ]; then
            if [ "$network" = "$network_backhaul" ]; then
                if [ "$backhaul_ssid" = "$def_backhaul_ssid" ] || [ "$mode" = "sta" ]; then
                    backhaul_ssid="$ssid_val"
                fi
            elif [ "$network" = "$network_guest" ]; then
                if [ "$guest_ssid" = "$def_guest_ssid" ]; then
                    guest_ssid="$ssid_val"
                fi
            fi
        fi

        if [ -n "$encryption_val" ] && [ "$disabled" -eq 0 ]; then
            if [ "$network" = "$network_backhaul" ]; then
                if [ "$backhaul_enc" = "$def_backhaul_enc" ] || [ "$mode" = "sta" ]; then
                    backhaul_enc="$encryption_val"
                fi
            elif [ "$network" = "$network_guest" ]; then
                if [ "$guest_enc" = "$def_guest_enc" ]; then
                    guest_enc="$encryption_val"
                fi
            fi
        fi

        if [ -n "$key_val" ] && [ "$disabled" -eq 0 ]; then
            if [ "$network" = "$network_backhaul" ]; then
                if [ "$backhaul_key" = "$def_backhaul_key" ] || [ "$mode" = "sta" ]; then
                    backhaul_key="$key_val"
                fi
            elif [ "$network" = "$network_guest" ]; then
                if [ "$guest_key" = "$def_guest_key" ]; then
                    guest_key="$key_val"
                fi
            fi
        fi
    fi
}

# Configure the additional VAPs needed to be consistent with the configuration that
# would be produced if starting from a default configuration. If any VAPs
# need to be created, use the SSID with suitable suffix, encryption mode, and passphrase
# from the managed network vaps
__repacd_reset_additional_config() {
    config_load wireless
    config_foreach __repacd_resolve_additional_vaps wifi-iface $network_guest
    config_foreach __repacd_resolve_additional_vaps wifi-iface $network_backhaul

    __repacd_create_additional_vaps $network_backhaul "$backhaul_ssid" "$backhaul_enc" \
                                   "$backhaul_key"
    __repacd_create_additional_vaps $network_guest "$guest_ssid" "$guest_enc" \
                                   "$guest_key"
}

# Configure the 4 VAPs needed to be consistent with the configuration that
# would be produced if starting from a default configuration. If any VAPs
# need to be created, carry over the SSID, encryption mode, and passphrase
# from one of the existing ones.
__repacd_reset_existing_config() {
    config_load wireless
    config_foreach __repacd_resolve_vaps wifi-iface $managed_network

    __repacd_create_vaps "$resolved_ssid" "$resolved_enc" "$resolved_key"
}

# Set all VAPs for the given network and mode to disabled or enabled (per
# the parameters).
#
# input: $1 config: section name
# input: $2 network: network for which to update VAPs
# input: $3 mode: sta or ap
# input: $4 disable_24g: 1 - disable, 0 - enable
# input: $5 disable_5g: 1 - disable, 0 - enable
# input-output: $6 change counter
__repacd_disable_vap() {
    local config="$1"
    local disable_24g="$4"
    local disable_5g="$5"
    local mode network disabled
    local changed="$6"

    config_get device "$config" device
    config_get hwmode "$device" hwmode
    config_get type "$device" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ] ;then
        return
    fi
    config_get mode "$config" mode
    config_get network "$config" network
    config_get disabled "$config" disabled 0

    if [ "$2" = "$network" ] && __repacd_is_matching_mode "$3" "$mode"; then
        local desired_val
        if whc_is_5g_vap "$config"; then
            desired_val=$disable_5g
        else
            desired_val=$disable_24g
        fi

        if [ ! "$desired_val" = "$disabled" ]; then
            uci_set wireless "$config" disabled "$desired_val"
            changed=$((changed + 1))
            eval "$6='$changed'"
            __repacd_echo "Set VAP $config to Disabled=$desired_val"
        fi
    fi
}
# Set invalid bssid to make sure
# when there is change in RE role
# bssid is getting reset.
__repacd_delete_bssid() {
    local config="$1"
    local mode network disabled
    local bssid="00:00:00:00:00:00"

    config_get device "$config" device
    config_get hwmode "$device" hwmode
    config_get type "$device" type

    config_get mode "$config" mode
    config_get network "$config" network
    config_get disabled "$config" disabled 0

    if [ "$mode" = "sta" ]; then
        uci_set wireless "$config" bssid "$bssid"
        __repacd_echo "Set VAP $config to bssid=$bssid"
    fi
}
# Determine the radio on which the bSTA should be allocated.
#
# If a radio is marked as selected (using the repacd_map_bsta_selected config
# option), it will be used. If instead none is marked, the radio with the
# highest repacd_map_bsta_pref value will be used.
#
# input: $1 config: section name
# output: $2 selected_radio: the radio that is marked as selected
# output: $3 preferred_radio: the radio with the highest preference
__repacd_resolve_bsta_radio() {
    local config="$1"

    local bsta_selected='' bsta_preference=''
    config_get bsta_selected "$config" repacd_map_bsta_selected 0
    config_get bsta_preference "$config" repacd_map_bsta_preference

    if [ "$bsta_selected" -gt 0 ]; then
        eval "$2=$config"
    fi

    # Radios with no preference set are ignored. This is meant to indicate
    # the OEM never wants to use that radio.
    if [ -n "$bsta_preference" ]; then
        if [ "$bsta_preference" -gt "$map_bsta_max_preference" ]; then
            eval "$3=$config"
            map_bsta_max_preference="$bsta_preference"
        fi
    fi
}

# Update the radio on which the bSTA VAP is allocated based on the setting
# at the radio level.
#
# input: $1 config: section name
# input: $2 selected_radio: name of the radio on which to run the bSTA
# input: $3 network: network for which to update VAPs
# input-output: $4 change counter
__repacd_update_map_bsta_radio() {
    local config="$1"
    local selected_radio="$2"
    local changed="$4"

    local device hwmode type
    config_get device "$config" device
    config_get hwmode "$device" hwmode
    config_get type "$device" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ] ;then
        return
    fi

    local mode network disabled bssid
    config_get mode "$config" mode
    config_get network "$config" network
    config_get disabled "$config" disabled 0
    config_get bssid "$config" bssid

    if [ "$3" = "$network" ] && __repacd_is_matching_mode "sta" "$mode"; then
        if [ ! "$device" = "$selected_radio" ]; then
            uci_set wireless "$config" device "$selected_radio"
            changed=$((changed + 1))
            eval "$4='$changed'"
            __repacd_echo "Set VAP $config to device=$selected_radio"

            if [ -n "$bssid" ]; then
                uci delete "wireless.${config}.bssid"
                __repacd_echo "Removed BSSID from VAP $config due to radio change"
            fi
        fi

        if [ "$disabled" -eq 1 ]; then
            uci_set wireless "$config" disabled 0
            changed=$((changed + 1))
            eval "$4='$changed'"
            __repacd_echo "Set VAP $config to Disabled=0"
        fi
    fi
}

# Delete the bssid entry from the given STA interface.
#
# input: $1 config: section name
# input: $2 network: network being managed
# output: $3 config_changed: number of configurations changed
__repacd_delete_bssid_entry() {
    local config="$1"
    local network_to_match="$2"
    local changed="$3"

    local device hwmode network mode bssid

    config_get device "$config" device
    config_get hwmode "$device" hwmode
    config_get network "$config" network
    config_get type "$device" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ] \
        || [ "$network" != "$network_to_match" ]; then
        return
    fi

    config_get mode "$config" mode

    if __repacd_is_matching_mode 'sta' "$mode"; then
        config_get bssid "$config" bssid ''
        if [ -n "$bssid" ]; then
            __repacd_echo "Deleting BSSID $bssid"
            uci delete "wireless.${config}.bssid"
            changed=$((changed + 1))
            eval "$3='$changed'"
        fi
    fi
}

# Change the wsplcd running mode based on the value provided.
#
# input: $1 new_mode: value to set wsplcd run mode to
# input: $2 new_deep_clone: whether to enable deep cloning (which copies the
#                       channel and locks the association to the CAP)
# input: $3 new_deep_clone_no_bssid: deep cloning without BSSID cloning
# input: $4 config_sta: whether to use the extension to configure a STA
#                       interface during cloning
# input: $5 map_enable: revision of MAP specification code is currently operating on
# input-output: $6 changed: count of the changes
__repacd_configure_wsplcd() {
    local new_mode=$1
    local new_deep_clone=$2
    local new_deep_clone_no_bssid=$3
    local new_config_sta=$4
    local new_map_enable=$5
    local changed="$6"
    local mode deep_clone deep_clone_no_bssid manage_vapind enabled
    local map_bss_conf

    if [ -f $WSPLCD_INIT ]; then
        config_load wsplcd
        config_get mode config 'RunMode'
        config_get deep_clone config 'DeepClone'
        config_get deep_clone_no_bssid config 'DeepCloneNoBSSID'
        config_get config_sta config 'ConfigSta'
        config_get map_enable config 'MapEnable'
        config_get map_bss_conf config 'MapGenericPolicyFile'
        config_get manage_vapind config 'ManageVAPInd'
        config_get_bool enabled config 'HyFiSecurity' 0

        if [ ! "$mode" = "$new_mode" ]; then
            uci_set wsplcd config 'RunMode' "$new_mode"
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd
            __repacd_echo "Set wsplcd to $new_mode mode"
            wsplcd_restart=1
        fi

        if [ ! "$deep_clone" = "$new_deep_clone" ]; then
            uci_set wsplcd config 'DeepClone' "$new_deep_clone"
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd
            __repacd_echo "Set wsplcd DeepClone=$new_deep_clone"
            wsplcd_restart=1
        fi

        if [ ! "$deep_clone_no_bssid" = "$new_deep_clone_no_bssid" ]; then
            uci_set wsplcd config 'DeepCloneNoBSSID' "$new_deep_clone_no_bssid"
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd
            __repacd_echo "Set wsplcd DeepCloneNoBSSID=$new_deep_clone_no_bssid"
            wsplcd_restart=1
        fi

        if [ ! "$config_sta" = "$new_config_sta" ]; then
            uci_set wsplcd config 'ConfigSta' "$new_config_sta"
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd
            __repacd_echo "Set wsplcd ConfigSta=$new_config_sta"
            wsplcd_restart=1
        fi

        if [ ! "$map_enable" = "$new_map_enable" ]; then
            uci_set wsplcd config 'MapEnable' "$new_map_enable"
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd
            __repacd_echo "Set wsplcd MapEnable=$new_map_enable"
            wsplcd_restart=1
        fi

        if [ "$new_map_enable" -gt 0 ] && \
            [ ! "$map_bss_conf" = "$WSPLCD_MAP_BSS_POLICY_PATH" ]; then
            uci_set wsplcd config 'MapGenericPolicyFile' "$WSPLCD_MAP_BSS_POLICY_PATH"
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd
            __repacd_echo "Set wsplcd MapGenericPolicyFile=$WSPLCD_MAP_BSS_POLICY_PATH"
            wsplcd_restart=1
        fi

        if [ ! "$manage_vapind" = "0" ]; then
            uci_set wsplcd config 'ManageVAPInd' "0"
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd
            __repacd_echo "Set wsplcd ManageVAPInd=0"
            wsplcd_restart=1
        fi

        if [ ! "$enabled" -eq "$wsplcd_enabled" ]; then
            uci_set wsplcd config 'HyFiSecurity' $wsplcd_enabled
            changed=$((changed + 1))
            eval "$6='$changed'"
            uci_commit wsplcd

            __repacd_echo "Set wsplcd HyFiSecurity=$wsplcd_enabled"
            if [ "$wsplcd_enabled" -gt 0 ]; then
                __repacd_echo "Enabled security and configuration"
                wsplcd_start=1
            else
                __repacd_echo "Disabled security and configuration"
                wsplcd_stop=1
            fi
        fi

        if [ "$map_version" -gt 1 ]; then
            uci_set wsplcd config 'MapEnable' $map_version
            __repacd_echo "Set wsplcd MapEnable=$map_version"
            if [ "$map_ts_enabled" -gt 0 ]; then
                uci_set wsplcd config 'NumberOfVLANSupported' $num_vlan_supported
                uci_set wsplcd config 'Map2TrafficSepEnabled' $map_ts_enabled
                uci_set wsplcd config 'CombinedR1R2Backhaul' $map_single_r1r2_bh
            fi
        fi
    fi
}

# Change the hyd running mode based on the value provided.
#
# input: $1 map_version: value to set hyd run mode to based on version
# input: $2 is_controller: device mode
__repacd_configure_hyd_map() {
    local version=$map_version
    local is_controller=$is_controller

    if [ "$version" -ge 1 ]; then
        # Set Forwarding Mode to SINGLE to disable HA, HD
        uci_set $MAP hy 'ForwardingMode' 'SINGLE'
        uci_set $MAP MultiAP 'MapVersion' $version

        if [ "$map_ts_enabled" -gt 0 ]; then
            uci_set repacd MAPConfig 'MapTrafficSeparationActive' 1
            uci_set $MAP MultiAP 'Map2TrafficSepEnabled' 1
            uci_set $MAP MultiAP 'NumberOfVLANSupported' $num_vlan_supported
            uci_set $MAP MultiAP 'CombinedR1R2Backhaul' $map_single_r1r2_bh
            uci_set $MAP MultiAP 'VlanNetworkPrimary' $map_primary_nw

            if [ "$is_controller" -gt 0 ]; then
                config_get fronthaul_ssid MAPConfig FronthaulSSID
                config_get primary_vlan_id MAPConfig 'VlanIDNwPrimary' '0'
                config_get pcp MAPConfig 'Map8021QPCP' '0'
                config_get additional_fh MAPConfig AdditionalFH

                uci_set $MAP MultiAP 'FronthaulSSIDPrimary' $fronthaul_ssid
                uci_set $MAP MultiAP 'Map8021QPCP' $pcp
                uci_set $MAP MultiAP 'VlanIDNwPrimary' $primary_vlan_id
                uci_set $MAP MultiAP 'AdditionalFH' $additional_fh

                local num_vlan=$num_vlan_supported
                for i in One Two Three; do
                    config_get fronthaul_ssid MAPConfig "FronthaulSSIDNw"$i ''
                    config_get vlan_id MAPConfig "VlanIDNw"$i '0'

                    if [ "$num_vlan" -eq 0 -o "$num_vlan" -eq 1 ]; then
                        break
                    fi

                    uci_set $MAP MultiAP 'FronthaulSSIDNw'$i $fronthaul_ssid
                    uci_set $MAP MultiAP 'VlanIDNw'$i $vlan_id

                    num_vlan=$((num_vlan-1))
                done
            fi
        fi
    fi

    uci_commit $MAP
}

# Change whether mcsd is enabled and running or not
#
# input: $1 manage_mcsd: whether repacd is to manage the state of mcsd
# input: $2 enable_son: whether SON mode is enabled or not (where this could
#                       include MAP)
__repacd_config_mcsd() {
    local manage_mcsd=$1
    local enable_son=$2

    if [ "$manage_mcsd" -gt 0 ] && [ -f "$MCSD_INIT" ]; then
        if [ "$enable_son" -gt 0 ]; then
            uci_set mcsd config 'Enable' 0
            uci_commit mcsd
            # Stop mcsd and keep attempting to stop it in case it
            # is being restarted by a hotplug event.
            while pgrep mcsd;
            do
                /etc/init.d/mcsd stop
                sleep 2
            done
        else  # switching to non-SON mode, so enable mcsd
            uci_set mcsd config 'Enable' 1
            uci_commit mcsd
            /etc/init.d/mcsd start
        fi
    fi
}

# Change the hyd and/or lbd configuration based on the parameters provided
# and the allowed feature settings.
#
# input: $1 enable_steering: 1 - AP interfaces support steering;
#                            0 - they do not
# input: $2 disable_ap_steering: 1 - disable AP steering feature
# input: $3 enable_son: 1 - multi-AP SON mode should be enabled (so
#                           long as it is not prohibited by config);
#                       0 - multi-AP SON mode should not be enabled
# input: $4 son_mode: one of HYROUTER or HYCLIENT; only relevant if enable_son
#                     is 1 and SON mode is not prohibited by the config
# input-output: $5 changed: count of the changes
__repacd_configure_son() {
    local enable_steering=$1
    local disable_ap_steering=$2
    local enable_son=$3
    local son_mode="$4"
    local changed="$5"

    local enable_steering_mask enable_son_mask manage_mcsd
    config_load repacd
    config_get_bool enable_steering_mask repacd 'EnableSteering' 1
    config_get_bool enable_son_mask repacd 'EnableSON' 1
    config_get_bool manage_mcsd repacd 'ManageMCSD' 1

    # If the config does not permit steering or multi AP logic, force it
    # off.
    if [ "$enable_steering_mask" -eq 0 ]; then
        enable_steering=0
    fi

    if [ "$enable_son_mask" -eq 0 ]; then
        enable_son=0
    fi

    # If the package is not even installed, then we will fall back to
    # the uncoordinated steering mode (if enabled).
    if [ -f $HYD_INIT  ]; then
        local cur_mode hyd_enabled
        config_load $MAP
        config_get cur_mode config 'Mode'
        config_get hyd_enabled config 'Enable'
        config_get disable_steering config 'DisableSteering'

        if [ ! "$cur_mode" = "$son_mode" ]; then
            uci_set $MAP config 'Mode' "$son_mode"
            changed=$((changed + 1))
            eval "$5='$changed'"
            uci_commit $MAP
            __repacd_echo "Set hyd Mode=$son_mode"
        fi

        if [ ! "$disable_steering" = "$disable_ap_steering" ]; then
            uci_set $MAP config 'DisableSteering' "$disable_ap_steering"
            changed=$((changed + 1))
            eval "$5='$changed'"
            uci_commit $MAP
            __repacd_echo "Set hyd DisableSteering=$disable_ap_steering"
        fi

        if [ ! "$hyd_enabled" = "$enable_son" ]; then
            uci_set $MAP config 'Enable' "$enable_son"
            changed=$((changed + 1))
            eval "$5='$changed'"
            uci_commit $MAP

            /etc/init.d/qrfs disable
            /etc/init.d/qrfs stop

            __repacd_config_mcsd "$manage_mcsd" "$enable_son"

            # hyd should be started/stopped based on the hotplug hooks
            # it has installed.
            if [ "$enable_son" -gt 0 ]; then
                __repacd_echo "Enabled Wi-Fi SON mode"
                hyd_start=1
            else
                __repacd_echo "Disabled Wi-Fi SON mode"
                hyd_stop=1
            fi
        fi

        if [ "$enable_son" -gt 0 ]; then
            enable_steering=0
        fi
    fi

    if [ -f $LBD_INIT ]; then
        local lbd_enabled
        config_load $MAPLBD
        config_get lbd_enabled config 'Enable'

        if [ ! "$lbd_enabled" = "$enable_steering" ]; then
            uci_set $MAPLBD config 'Enable' "$enable_steering"
            changed=$((changed + 1))
            eval "$5='$changed'"
            uci_commit $MAPLBD

            # Start/stop is handled when Wi-Fi interfaces are reconfigured.
            if [ "$enable_steering" -gt 0 ]; then
                __repacd_echo "Enabled Wi-Fi steering"
            else
                __repacd_echo "Disabled Wi-Fi steering"
            fi
        fi
    fi
}


# Change the configuration on the wifi-device object to match what is desired
# (either QWrap enabled or disabled based on the second argument).
#
# input: $1 config: section to update
# input: $2 1 - enable, 0 - disable
# input-output: $3 change counter
__repacd_config_qwrap_device() {
    local config="$1"
    local mode network
    local changed="$3"

    # @todo This will need to be updated for 3 radio configurations. The
    #       qwrap_enable should be set for the radio with the backhaul and
    #       qwrap_dbdc_enable should be set for the radios with only an AP
    #       interface.
    config_get hwmode "$config" hwmode
    config_get type "$config" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ]; then
        return
    fi

    if whc_is_5g_radio "$1"; then
        local qwrap_enable
        config_get qwrap_enable "$config" qwrap_enable
        if [ ! "$2" = "$qwrap_enable" ]; then
            uci_set wireless "$config" qwrap_enable "$2"
            changed=$((changed + 1))
            eval "$3='$changed'"
            __repacd_echo "Set radio $config to QWrap Enabled=$2"
        fi
    else   # must be 2.4 GHz
        local qwrap_dbdc_enable
        config_get qwrap_dbdc_enable "$config" qwrap_dbdc_enable
        if [ ! "$2" = "$qwrap_dbdc_enable" ]; then
            uci_set wireless "$config" qwrap_dbdc_enable "$2"
            changed=$((changed + 1))
            eval "$3='$changed'"
            __repacd_echo "Set radio $config to QWrap DBDC Enabled=$2"
        fi
    fi
}

# Set the option that indicates whether the DBDC repeater feature should be
# enabled or not.
#
# input: $1 config: section to update
# input: $2 1 - enable, 0 - disable
# input-output: $3 change counter
__repacd_config_dbdc_device() {
    local config="$1"
    local changed="$3"

    local dbdc_enable
    config_get hwmode "$config" hwmode
    config_get type "$config" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ]; then
        return
    fi

    config_get dbdc_enable "$config" dbdc_enable 1
    if [ ! "$2" = "$dbdc_enable" ]; then
        uci_set wireless "$config" dbdc_enable "$2"
        changed=$((changed + 1))
        eval "$3='$changed'"
        __repacd_echo "Set radio $config to DBDC Enabled=$2"
    fi
}

# Set the country
#
# input: $1 config: section to update
# input: $2 country to update
__repacd_config_set_device_country() {
    local config="$1"
    local country="$2"
    config_get hwmode "$config" hwmode
    config_get type "$config" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ]; then
        return
    fi

    uci_set wireless "$config" country "$country"
    uci_commit wireless
    __repacd_echo "Set radio $config to country=$country"
}

# Enable Radio
#
# input: $1 config: section to update
__repacd_config_set_radio_enable() {
    local config="$1"
    local country="$2"
    config_get hwmode "$config" hwmode
    config_get type "$config" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ]; then
        return
    fi

    uci_set wireless "$config" disabled 0
    uci_commit wireless

    map_num_radio=$((map_num_radio + 1))
}

# Enable or disable the WPS Push Button Configuration Range Extender
# enhancement based on the current configuration.
# input: $1 force_cap_mode - whether to act as gateway connected even without
#                            a WAN interface
# input-output: $2 change count
__repacd_config_wps_pbc_enhc() {
    local force_gwcon_mode=$1
    local changed="$2"
    local cur_enable

    if __repacd_gw_mode || [ "$force_gwcon_mode" -gt 0 ] || \
       __repacd_is_wds_mode || __repacd_is_son_mode; then
        if [ "$traffic_separation_enabled" -gt 0 ]; then
            enable_wps_pbc_enhc=1
        else
            enable_wps_pbc_enhc=0
        fi
    else
        # Must be QWRAP or ExtAP mode, where we want distinct SSIDs for the
        # RE interfaces.
        enable_wps_pbc_enhc=1
    fi

    config_load wireless
    config_get cur_enable qcawifi wps_pbc_extender_enhance '0'

    if [ ! "$enable_wps_pbc_enhc" = "$cur_enable" ]; then
        # Create the section if it does not exist.
        uci set wireless.qcawifi=qcawifi
        uci_set wireless qcawifi wps_pbc_extender_enhance $enable_wps_pbc_enhc

        __repacd_echo "Set qcawifi.wps_pbc_extender_enhance=$enable_wps_pbc_enhc"
        changed=$((changed + 1))
        eval "$2='$changed'"
    fi
}

# Change the configuration on the wifi-iface object to match what is desired.
# The values provided are determined by the caller based on the desired
# mode of operation (eg. QWrap/ExtAP or not).
#
# input: $1 config: section to update
# input: $2 network: only update if network matches this value
# input: $3 enable_wds: 1 - enable, 0 - disable
# input: $4 qwrap_ap: 1 - enable, 0 - disable
# input: $5 extap: 1 - enable, 0 disable
# input: $6 block_dfs_chan: 1 - block DFS channels, 0 - do not block them
# input: $7 enable_rrm: 1 - enable, 0 disable
# input: $8 re_scalingfactor: 0 - ignore, 1 to 100 valid for sta
# input: $9 default_root_dist: 0 - ignore, 255 - invalid root distance
# input: $10 cap_snr: 0 - disabled, 1-100 valid
# input-output: $11 change counter
__repacd_config_iface() {
    local config="$1"
    local device mode network enable_wds qwrap_ap extap block_dfs enable_rrm
    local re_scalingfactor root_distance cap_snr wps_pbc_skip
    local bssid="00:00:00:00:00:00"
    local num_changes=0
    local changed="${11}"

    config_get device "$config" device
    config_get hwmode "$device" hwmode
    config_get type "$device" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ] ;then
       return
    fi

    config_get mode "$config" mode
    config_get network "$config" network
    config_get enable_wds "$config" wds '0'
    config_get qwrap_ap "$config" qwrap_ap '0'
    config_get extap "$config" extap '0'
    config_get block_dfs "$config" blockdfschan '0'
    config_get enable_rrm "$config" rrm '0'
    config_get re_scalingfactor "$config" re_scalingfactor '0'
    config_get root_distance "$config" root_distance '0'
    config_get cap_snr "$config" caprssi '0'
    config_get wps_pbc_skip "$config" wps_pbc_skip '0'

    if [ "$2" = "$network" ]; then
        if [ ! "$3" = "$enable_wds" ]; then
            uci_set wireless "$config" wds "$3"
            num_changes=$((num_changes + 1))
            __repacd_echo "Set iface $config to WDS=$3"
        fi

        # When operating in WDS/SON mode (since we do not use the repeater
        # enhancement), set the option to skip activating WPS PBC on a
        # connected STA interface. This allows the WPS button to be pressed on
        # an RE without causing it to disconnect from its upstream device.
        if [ "$mode" = 'sta' ]; then
            if [ ! "$3" = "$wps_pbc_skip" ]; then
                uci_set wireless "$config" wps_pbc_skip "$3"
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to wps_pbc_skip=$3"
            fi
        fi

        # These should only be set on AP interfaces.
        if __repacd_is_matching_mode 'ap' "$mode"; then
            if [ ! "$4" = "$qwrap_ap" ]; then
                uci_set wireless "$config" qwrap_ap "$4"
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to QWrapAP=$4"
            fi

            # @todo If there are multiple 5 GHz radios, will need to figure
            #       out which can act as the backhaul.

            # Set the interface into wrap or vanilla AP mode as appropriate
            if whc_is_5g_radio $device; then
                if [ "$4" -gt 0 ]; then
                    if [ ! "$mode" = 'wrap' ]; then
                        uci_set wireless "$config" mode 'wrap'
                        num_changes=$((num_changes + 1))
                        __repacd_echo "Set iface $config mode to wrap"
                    fi
                else  # WDS or ExtAP mode
                    if [ ! "$mode" = 'ap' ]; then
                        uci_set wireless "$config" mode 'ap'
                        num_changes=$((num_changes + 1))
                        __repacd_echo "Set iface $config mode to ap"
                    fi
                fi
            fi

            if [ ! "$6" = "$block_dfs" ]; then
                uci_set wireless "$config" blockdfschan "$6"
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to BlockDFSChan=$6"
            fi

            if [ ! "$7" = "$enable_rrm" ]; then
                uci_set wireless "$config" rrm "$7"
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to RRM=$7"
            fi
        fi

        if [ ! "$5" = "$extap" ]; then
            uci_set wireless "$config" extap "$5"
            num_changes=$((num_changes + 1))
            __repacd_echo "Set iface $config to ExtAP=$5"
        fi

        if [ "$daisy_chain" -gt 0 ] && \
            __repacd_is_matching_mode 'sta' "$mode"; then

            # Need to resolve 2.4G & 5G BSSID, So until then configure invalid BSSID
            # to avoid association on 2.4G & 5G interface at bootup.
            # Check if bssid updated by wifimon/daisychain, needs restart
            if [ "$bssid_resolve_state" = "resolving" ]; then
                uci_set wireless "$config" bssid "$bssid"
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to BSSID=$bssid"
            fi

            if [ ! "$8" = "$re_scalingfactor" ]; then
                uci_set wireless "$config" re_scalingfactor "$8"
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to RE_ScalingFactor=$8"
            fi

            if [ ! "${10}" = "$cap_snr" ]; then
                uci_set wireless "$config" caprssi "${10}"
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to caprssi=${10}"
            fi
        fi

            uci_set wireless "$config" root_distance "$9"
            num_changes=$((num_changes + 1))
            __repacd_echo "Set iface $config to RootDistance=$9"

        if [ "$num_changes" -gt 0 ]; then
            changed=$((changed + 1))
            eval "${11}='$changed'"
        fi
    fi
}

# Switch the device into acting as the CAP (main gateway).
# Also update the range extension mode as necessary.
#
# input: $1 is_cap: whether the device should act as the central
#                   AP or a secondary gateway connected AP
__repacd_config_gwcon_ap_mode() {
    local is_cap=$1
    local wsplcd_mode son_mode
    local rate_scaling_factor=0
    local default_root_dist=0

    # The WDS, VAP independent, and QWrap AP settings also need to be updated
    # based on the range extension mode.
    local enable_wds enable_rrm enable_qwrap_ap enable_extap
    local block_dfs enable_multi_ap disable_steering=0 config_sta=1
    local map_enable=0
    __repacd_get_config_re_mode config_re_mode
    __repacd_get_re_mode resolved_re_mode
    if __repacd_is_auto_re_mode $config_re_mode || __repacd_is_wds_mode || \
       __repacd_is_son_mode; then
        if __repacd_is_auto_re_mode $config_re_mode || \
           __repacd_is_son_mode; then
            __repacd_echo "Using SON mode for GW Connected AP"
            enable_multi_ap=1
        else   # Must be vanilla WDS
            __repacd_echo "Using WDS mode for GW Connected AP"
            enable_multi_ap=0
        fi

        enable_wds=1
        enable_rrm=1
        enable_qwrap_ap=0
        enable_extap=0

        # In WDS/SON modes, we let the OEM customize whether DFS channels
        # should be permitted.
        if __repacd_is_block_dfs; then
            block_dfs=1
        else
            block_dfs=0
        fi

        wsplcd_enabled=1
    else
        __repacd_echo "Using Non-WDS mode for GW Connected AP"
        enable_wds=0
        enable_multi_ap=0
        enable_rrm=0
        enable_qwrap_ap=0
        enable_extap=0

        # In QWrap/ExtAP mode, DFS channels should always be disallowed (as it
        # does not appear to suppor them currently). This may be able to
        # relaxed in the future.
        block_dfs=1

        # Since QWrap/ExtAP mode on the CAP is for mimicking a non-QCA AP, do
        # not run an IEEE P1905.1 registrar.
        wsplcd_enabled=0
    fi

    config_load repacd
    config_get bssid_resolve_state WiFiLink 'BSSIDResolveState' 'resolving'

    # In GW-connected AP mode, only the AP interfaces are enabled.
    local disable_24g_sta=1 disable_5g_sta=1 disable_24g_ap=0 disable_5g_ap=0
    config_load wireless
    config_foreach __repacd_disable_vap wifi-iface \
        $managed_network 'sta' $disable_24g_sta $disable_5g_sta config_changed
    config_foreach __repacd_disable_vap wifi-iface \
        $managed_network 'ap' $disable_24g_ap $disable_5g_ap config_changed

    # The QWrap parameters should always be set to 0 on the CAP.
    config_foreach __repacd_config_qwrap_device wifi-device \
        0 config_changed

    # Similarly, the DBDC repeater feature should be disabled on the
    # CAP.
    config_foreach __repacd_config_dbdc_device wifi-device \
        0 config_changed

    # If son_mode is HYCLIENT root distance whould be reest to 255
    # during restart_in_cap_mode to avoid island issue
    if [ "$is_cap" -gt 0 ]; then
        default_root_dist=0
    else
        default_root_dist=255
    fi


    # Now set up the interfaces in the right way.
    config_foreach __repacd_config_iface wifi-iface \
        $managed_network $enable_wds $enable_qwrap_ap $enable_extap \
        $block_dfs $enable_rrm $rate_scaling_factor $default_root_dist $capsnr config_changed

    if [ "$traffic_separation_active" -gt 0 ]; then
        config_foreach __repacd_config_iface wifi-iface \
            $network_backhaul $enable_wds $enable_qwrap_ap $enable_extap \
            $block_dfs $enable_rrm $rate_scaling_factor $default_root_dist $capsnr config_changed

        config_foreach __repacd_config_iface wifi-iface \
            $network_guest $enable_wds $enable_qwrap_ap $enable_extap \
            $block_dfs $enable_rrm $rate_scaling_factor $default_root_dist $capsnr config_changed
    fi

    uci_commit wireless

    uci_set repacd repacd Role 'CAP'
    uci_commit repacd

    if [ "$is_cap" -gt 0 ]; then
        wsplcd_mode='REGISTRAR'
        son_mode='HYROUTER'
    else
        wsplcd_mode='ENROLLEE'
        son_mode='HYCLIENT'
    fi

    # Deep cloning is not relevant in registrar mode, but we set it to 1
    # anyways (since that is the default).
    __repacd_configure_wsplcd $wsplcd_mode 1 0 $config_sta $map_enable \
                              config_changed

    __repacd_configure_son $enable_wds $disable_steering $enable_multi_ap \
        $son_mode config_changed
}

# Switch the device to act in one of the NonCAP configurations.
# input: $1 disable_ap - whether to disable the AP interfaces
# input: $2 deep_clone - whether to use deep cloning in wsplcd
# input: $3 deep_clone_no_bssid - whether to use deep cloning without BSSID cloning in wsplcd
__repacd_config_noncap_mode() {
    local disable_ap=$1
    local deep_clone=$2
    local deep_clone_no_bssid=$3

    # The WDS and QWrap AP settings also need to be updated based on the
    # range extension mode.
    local enable_wds enable_qwrap_ap enable_extap enable_dbdc_repeater
    local block_dfs enable_rrm enable_multi_ap disable_steering=0 config_sta=1
    local map_enable=0
    local rate_scaling_factor=$RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR
    local default_root_dist=$RE_ROOT_AP_DISTANCE_INVALID
    local disable_24g_sta=1 disable_5g_sta=0
    local disable_24g_ap=$disable_ap disable_5g_ap=$disable_ap
    if __repacd_is_wds_mode || __repacd_is_son_mode; then
        if __repacd_is_wds_mode; then
            __repacd_echo "Using WDS mode for NonCAP"
        else  # Must be SON mode
            __repacd_echo "Using SON mode for NonCAP"
        fi

        enable_wds=1
        enable_qwrap_ap=0
        enable_extap=0

        # Even if we are not operating in fully coordinated steering mode,
        # we should enable RRM for use in the uncoordinated steering
        # environment.
        enable_rrm=1

        # In WDS mode, we let the OEM customize whether DFS channels should
        # be permitted.
        if __repacd_is_block_dfs; then
            block_dfs=1
        else
            block_dfs=0
        fi

        wsplcd_enabled=1

        __repacd_get_rate_scaling_factor rate_scaling_factor
        config_get capsnr WiFiLink 'PreferCAPSNRThreshold5G' '0'
    else
        enable_wds=0

        # Until steering can be well supported on QWRAP/ExtAP, there is no real
        # need to have RRM enabled.
        enable_rrm=0

        # wsplcd needs WDS in order to work (as it sends/receives using the
        # bridge interface MAC address). Plus, it is not too likely that the
        # main AP will be running an IEEE P1905.1 registrar.
        wsplcd_enabled=0

        if [ "$disable_ap" -eq 0 ]; then
            if __repacd_is_qwrap_mode; then
                __repacd_echo "Using QWrap mode for NonCAP"
                enable_qwrap_ap=1
                enable_extap=0

            else
                __repacd_echo "Using ExtAP mode for NonCAP"
                enable_qwrap_ap=0
                enable_extap=1
            fi

            # In QWrap/ExtAP mode, DFS channels should always be disallowed
            # (as these modes may not support them properly).
            block_dfs=1
        else  # client mode
            if __repacd_is_qwrap_mode; then
                __repacd_echo "Using QWrap mode for NonCAP"
                enable_qwrap_ap=0
                enable_extap=0

                # @todo What mode should be used here? The STA interface is not
                #       even created if it is not in QWRAP or WDS. We could
                #       potentially consider standalone Proxy STA
                #       mode, but we need details on how to configure this.
            else
                __repacd_echo "Using ExtAP mode for NonCAP"
                enable_qwrap_ap=0
                enable_extap=1
            fi

            # We'll rely on the main AP to decide on DFS or not.
            block_dfs=0
        fi
    fi

    if __repacd_is_son_mode; then
        disable_24g_sta=0
        enable_dbdc_repeater=0
        enable_multi_ap=1
    else
        enable_multi_ap=0

        # Although currently in non-SON mode we do not enable both STA
        # interfaces, just in case we do in the future, set this flag. It
        # should make no difference if only one STA interface is active.
        enable_dbdc_repeater=1
    fi

    config_load repacd
    config_get bssid_resolve_state WiFiLink 'BSSIDResolveState' 'resolving'

    config_load wireless

    if [ "$traffic_separation_active" -gt 0 ]; then
        config_foreach __repacd_disable_vap wifi-iface \
            $network_backhaul 'sta' $disable_24g_sta $disable_5g_sta config_changed
    else
        config_foreach __repacd_disable_vap wifi-iface \
            $managed_network 'sta' $disable_24g_sta $disable_5g_sta config_changed
    fi
    config_foreach __repacd_disable_vap wifi-iface \
        $managed_network 'ap' "$disable_24g_ap" "$disable_5g_ap" config_changed

    # First set the special options for QWRAP and DBDC repeaters.
    config_foreach __repacd_config_qwrap_device \
        wifi-device $enable_qwrap_ap config_changed
    config_foreach __repacd_config_dbdc_device wifi-device \
        $enable_dbdc_repeater config_changed

    config_foreach __repacd_config_iface wifi-iface \
        $managed_network $enable_wds $enable_qwrap_ap $enable_extap \
        $block_dfs $enable_rrm $rate_scaling_factor $default_root_dist $capsnr config_changed

    if [ "$traffic_separation_active" -gt 0 ]; then
        config_foreach __repacd_config_iface wifi-iface \
            $network_backhaul $enable_wds $enable_qwrap_ap $enable_extap \
            $block_dfs $enable_rrm $rate_scaling_factor $default_root_dist $capsnr config_changed

        config_foreach __repacd_config_iface wifi-iface \
            $network_guest $enable_wds $enable_qwrap_ap $enable_extap \
            $block_dfs $enable_rrm $rate_scaling_factor $default_root_dist $capsnr config_changed
    fi

    __repacd_config_independent_vaps

    uci_commit wireless

    uci_set repacd repacd Role 'NonCAP'
    uci_commit repacd

    __repacd_configure_wsplcd 'ENROLLEE' "$deep_clone" "$deep_clone_no_bssid" \
                              $config_sta $map_enable config_changed

    __repacd_configure_son $enable_wds $disable_steering $enable_multi_ap \
        'HYCLIENT' config_changed
}

# Switch the device into acting as a range extender.
# Also update the range extension mode as necessary.
__repacd_config_re_mode() {
    local disable_ap=0 deep_clone=1 deep_clone_no_bssid=0

    # We do deep cloning without BSSID for daisy chaining.
    [ "$daisy_chain" -gt 0 ] && deep_clone_no_bssid=1

    __repacd_config_noncap_mode $disable_ap $deep_clone $deep_clone_no_bssid
}

# Switch the device into acting as a pure client device (no AP interfaces
# enabled).
__repacd_config_client_mode() {
    local disable_ap=1 deep_clone=0
    __repacd_config_noncap_mode $disable_ap $deep_clone 0
}

# Change the configuration on the wifi-iface object to match what is desired.
# This function is for Multi-AP mode.
#
# input: $1 config: section to update
# input: $2 network: only update if network matches this value
# input: $3 block_dfs_chan: 1 - block DFS channels, 0 - do not block them
# input-output: $4 change counter
__repacd_config_iface_map() {
    local config=$1
    local enable_wds=1 qwrap_ap=0 extap=0 enable_rrm=1 re_scalingfactor=0
    local default_root_dist=0 cap_snr=0

    __repacd_config_iface "$1" "$2" $enable_wds $qwrap_ap $extap "$3" $enable_rrm \
                          $re_scalingfactor $default_root_dist $cap_snr "$4"

    if [ "$map_version" -ge 2 ]; then
        config_get mode "$config" mode

        config_load 'wsplcd'
        config_get map2SetMboOcePmf config 'Map2EnableMboOcePmf'

        # These should only be set on AP interfaces.
        if __repacd_is_matching_mode 'ap' "$mode"; then
            # Set Mbo, Oce and PMF
            if [ "$map2SetMboOcePmf" -eq 1 ]; then
                uci_set wireless "$config" mbo 1
                uci_set wireless "$config" oce 1
                uci_set wireless "$config" ieee80211w 1
            fi

            # Set Interworking and ANQP
            uci_set wireless "$config" interworking 1
            uci del_list wireless."$config".anqp_elem="$anqp_ele"
            uci add_list wireless."$config".anqp_elem="$anqp_ele"
        fi

        # Update config when Traffic Separation is enabled
        if [ "$map_ts_enabled" -eq 1 ]; then
            config_load network
            for i in Primary One Two Three; do
                config_get nw_name MAPConfig "VlanNetwork"$i '0'
                __repacd_config_iface "$1" "$nw_name" $enable_wds $qwrap_ap $extap "$3" \
                                      $enable_rrm $re_scalingfactor $default_root_dist \
                                      $cap_snr "$4"
            done
            __repacd_config_iface "$1" "$map_backhaul_nw" $enable_wds $qwrap_ap $extap "$3" \
                                  $enable_rrm $re_scalingfactor $default_root_dist $cap_snr "$4"
        fi
    fi
}

# Generate the Multi-AP BSS instantiation config file for wsplcd based on
# the selected template and SSID settings.
# input-output: $1 change counter
__repacd_generate_map_bss_conf() {
    local changed="$1"

    local template_filename
    local template_path
    local fronthaul_ssid fronthaul_key
    local backhaul_ssid backhaul_key
    local fronthaul_authtype_str="0x0020" backhaul_authtype_str="0x0020"
    local backhaul_r2_authtype_str="0x0020"
    local fronthaul_authtype backhaul_authtype
    local primary_vlan_id pcp

    config_load repacd
    config_get template_filename MAPConfig BSSInstantiationTemplate
    config_get fronthaul_ssid MAPConfig FronthaulSSID
    config_get fronthaul_key MAPConfig FronthaulKey
    config_get additional_vaps MAPConfig 'AdditionalFH' ''
    config_get backhaul_ssid MAPConfig BackhaulSSID
    config_get backhaul_key MAPConfig BackhaulKey
    config_get fronthaul_authtype MAPConfig FronthaulAuthType 0
    config_get backhaul_authtype MAPConfig BackhaulAuthType 0

    if [ -z "${template_filename}" ]; then
        __repacd_echo "BSS instantiation template not specified"
        return 1
    fi

    template_path="${WSPLCD_MAP_TEMPLATE_DIR}/${template_filename}"
    if [ ! -r "${template_path}" ]; then
        __repacd_echo "BSS instantiation template ${template_path} not readable"
        return 1
    fi

    __repacd_echo "Using wsplcd BSS instantiation template: ${template_path}"

    if [ "$map_version" -ge 2 ]; then
        if [ $fronthaul_authtype -gt 0 ]; then
            fronthaul_authtype_str="0x0060"
        fi

        if [ $backhaul_authtype -eq 1 ]; then
            backhaul_authtype_str="0x0040"
        fi
    fi

    if [ -z $fronthaul_key ]; then
        fronthaul_key="NULL"
        fronthaul_authtype_str="0x0001"
    fi

    if [ -z $backhaul_key ]; then
        backhaul_key="NULL"
        backhaul_authtype_str="0x0001"
        backhaul_r2_authtype_str="0x0001"
    fi

    local tempfile
    tempfile=$(mktemp)
    cp "${template_path}" "${tempfile}"

    # Some of these replacements may not be used, but this covers all of the
    # cases of variables that need to be replaced.
    #
    # Note that in case the variable contains the sed delimeter, it needs to
    # be escaped to avoid a sed error.
    sed -i -e "s!__FH_SSID_REPLACE__!${fronthaul_ssid/!/\!}!g" \
           -e "s!__FH_KEY_REPLACE__!${fronthaul_key/!/\!}!g" \
           -e "s!__BH_SSID_REPLACE__!${backhaul_ssid/!/\!}!g" \
           -e "s!__BH_KEY_REPLACE__!${backhaul_key/!/\!}!g" \
           -e "s!__FHBH_SSID_REPLACE__!${fronthaul_ssid/!/\!}!g" \
           -e "s!__FHBH_KEY_REPLACE__!${fronthaul_key/!/\!}!g" \
           -e "s!__FH_AUTH_TYPE_REPLACE__!${fronthaul_authtype_str/!/\!}!g" \
           -e "s!__FHBH_AUTH_TYPE_REPLACE__!${fronthaul_authtype_str/!/\!}!g" \
           "${tempfile}"

   ad_vap_index=1
   while [ $ad_vap_index -le $MAP_MAX_ADDITIONA_VAP ]; do
       ad_vap=$(eval "echo $additional_vaps | awk 'BEGIN { FS = \",\" }; { print \$$ad_vap_index }'")
       if [ -z $ad_vap ]; then
          sed -i -e "s!__FHA"$ad_vap_index"_SSID_REPLACE__!"teardown"!g" "${tempfile}"    # Mark teardown for network $i and vap $ad_vap_index if config is not provided
       else
          fronthaul_ssid=$(eval "echo $ad_vap | awk 'BEGIN { FS = \":\" }; { print \$1 }'")
          fronthaul_key=$(eval "echo $ad_vap | awk 'BEGIN { FS = \":\" }; { print \$2 }'")
          authtype=$(eval "echo $ad_vap | awk 'BEGIN { FS = \":\" }; { print \$3 }'")
          __repacd_echo "BSSCONF_FILE: $ad_vap_index. ssid:$fronthaul_ssid key:$fronthaul_key auth:$authtype"

          fronthaul_authtype_str="0x0020"
          if [ "$map_version" -ge 2 ]; then
              if [ $authtype -gt 0 ]; then
                  fronthaul_authtype_str="0x0060"
              fi
          fi

          if [ -z $fronthaul_key ]; then
              fronthaul_key="NULL"
              fronthaul_authtype_str="0x0001"
          fi

          sed -i -e "s!__FHA"$ad_vap_index"_SSID_REPLACE__!${fronthaul_ssid/!/\!}!g" \
              -e "s!__FHA"$ad_vap_index"_KEY_REPLACE__!${fronthaul_key/!/\!}!g" \
              -e "s!__FHA"$ad_vap_index"_AUTH_TYPE_REPLACE__!${fronthaul_authtype_str/!/\!}!g" \
              -e "s!__FHBHA"$ad_vap_index"_SSID_REPLACE__!${fronthaul_ssid/!/\!}!g" \
              -e "s!__FHBHA"$ad_vap_index"_KEY_REPLACE__!${fronthaul_key/!/\!}!g" \
              -e "s!__FHBHA"$ad_vap_index"_AUTH_TYPE_REPLACE__!${fronthaul_authtype_str/!/\!}!g" \
              "${tempfile}"
       fi
       ad_vap_index=$((ad_vap_index+1))
   done

    if [ "$map_ts_enabled" -eq 0 ]; then
        sed -i -e "s!__BH_AUTH_TYPE_REPLACE__!${backhaul_authtype_str/!/\!}!g" \
                "${tempfile}"
    fi

    if [ "$map_version" -ge 2 ]; then
        if [ "$map_ts_enabled" -gt 0 ]; then
            config_get map_r1_sta_assoc_disallow MAPConfig 'R1AgentAssocDisAllowed' '0'
            config_get map_r2_sta_assoc_disallow MAPConfig 'R2AgentAssocDisAllowed' '0'
            config_get primary_vlan_id MAPConfig 'VlanIDNwPrimary' '0'
            config_get pcp MAPConfig 'Map8021QPCP' '0'
        fi

        if [ "$map_ts_enabled" -eq 0 ]; then
            __repacd_echo "Traffic Separation Disabled"
            __repacd_echo "Remove Vlan Config and Secondary Networks"
            map_r1_sta_assoc_disallow=0
            map_r2_sta_assoc_disallow=0
            primary_vlan_id=0
            pcp=0

            sed -i -e "s!__R1_BSTA_ASSOC_DISALLOW_BH1__!${map_r1_sta_assoc_disallow/!/\!}!g" \
                -e "s!__R2_BSTA_ASSOC_DISALLOW_BH1__!${map_r2_sta_assoc_disallow/!/\!}!g" \
                "${tempfile}"

            # Mark second backhaul config to teardown to remove
            sed -i -e "s!__BH2_SSID_REPLACE__!"teardown"!g" \
            "${tempfile}"
        elif [ "$map_r1_sta_assoc_disallow" -gt 0 -o "$map_r2_sta_assoc_disallow" -gt 0 ]; then
            sed -i -e "s!__R1_BSTA_ASSOC_DISALLOW_BH1__!${map_r1_sta_assoc_disallow/!/\!}!g" \
                -e "s!__R2_BSTA_ASSOC_DISALLOW_BH1__!${map_r2_sta_assoc_disallow/!/\!}!g" \
                "${tempfile}"

            # map_r2_sta_assoc_disallow is enabled update authtype as WPA2
            if [ "$map_r2_sta_assoc_disallow" -gt 0 ]; then
                sed -i -e "s!__BH_AUTH_TYPE_REPLACE__!${backhaul_r2_authtype_str}!}!g" \
                "${tempfile}"
            else
                sed -i -e "s!__BH_AUTH_TYPE_REPLACE__!${backhaul_authtype_str/!/\!}!g" \
                "${tempfile}"
            fi

            # Mark second backhaul config to teardown to remove
            sed -i -e "s!__BH2_SSID_REPLACE__!"teardown"!g" \
            "${tempfile}"
        elif [ "$map_r1_sta_assoc_disallow" -eq 0 -a "$map_r2_sta_assoc_disallow" -eq 0 ]; then
            # 2 backhaul are created . 1 with r1 STA assoc disAllowed another with r2
            # STA assoc disAllowed
            if [ "$map_single_r1r2_bh" -eq 1 ]; then
                sed -i -e "s!__R1_BSTA_ASSOC_DISALLOW_BH1__!0!g" \
                    -e "s!__R2_BSTA_ASSOC_DISALLOW_BH1__!0!g" \
                    -e "s!__BH_AUTH_TYPE_REPLACE__!${backhaul_authtype_str/!/\!}!g" \
                    "${tempfile}"

                # Mark second backhaul config to teardown to remove
                sed -i -e "s!__BH2_SSID_REPLACE__!"teardown"!g" \
                    "${tempfile}"
            else
                # Always update the Authtype as WPA2 for R1 agent assoc allowed backhaul BSS
                sed -i -e "s!__R1_BSTA_ASSOC_DISALLOW_BH1__!0!g" \
                    -e "s!__R2_BSTA_ASSOC_DISALLOW_BH1__!1!g" \
                    -e "s!__BH_AUTH_TYPE_REPLACE__!${backhaul_r2_authtype_str}!g" \
                    "${tempfile}"

                sed -i -e "s!__R1_BSTA_ASSOC_DISALLOW_BH2__!1!g" \
                    -e "s!__R2_BSTA_ASSOC_DISALLOW_BH2__!0!g" \
                    -e "s!__BH2_SSID_REPLACE__!${backhaul_ssid/!/\!}!g" \
                    -e "s!__BH2_AUTH_TYPE_REPLACE__!${backhaul_authtype_str/!/\!}!g" \
                    "${tempfile}"
            fi
        fi

        # Update primary information in bss.conf
        sed -i -e "s!__PRIMARY_VLAN__!${primary_vlan_id/!/\!}!g" \
            -e "s!__PCP__!${pcp/!/\!}!g" \
            "${tempfile}"

        # Create new bridge based on num Vlan configured by user
        config_load network
        local num_vlan=$num_vlan_supported
        fronthaul_authtype_str="0x0020"

        for i in One Two Three; do
            config_get fronthaul_ssid MAPConfig "FronthaulSSIDNw"$i ''
            config_get fronthaul_key MAPConfig "FronthaulKeyNw"$i ''
            config_get fronthaul_authtype MAPConfig "FronthaulAuthTypeNw"$i 0
            config_get vlan_id MAPConfig "VlanIDNw"$i '0'

            if [ $fronthaul_authtype -gt 0 ]; then
                fronthaul_authtype_str="0x0060"
            fi

            if [ -z $fronthaul_key ]; then
                fronthaul_key="NULL"
                fronthaul_authtype_str="0x0001"
            fi

            if [ -z "$fronthaul_ssid" -o "$num_vlan" -eq 0 -o "$num_vlan" -eq 1 ]; then
                fronthaul_ssid="teardown"
            fi

            if [ "$map_ts_enabled" -eq 0 ]; then
                fronthaul_ssid="teardown"
            fi

            sed -i -e "s!__FH_SSID_REPLACE_NW_"$i"__!${fronthaul_ssid/!/\!}!g" \
                -e "s!__FH_KEY_REPLACE_NW_"$i"__!${fronthaul_key/!/\!}!g" \
                -e "s!__FH_AUTH_TYPE_REPLACE_NW_"$i"__!${fronthaul_authtype_str/!/\!}!g" \
                -e "s!__VLAN_ID_NW_"$i"__!${vlan_id/!/\!}!g" \
                "${tempfile}"

            num_vlan=$((num_vlan-1))
        done
    fi

    # Get short hand name from config file and remove unused profiles
    config_SHN=$(cat ${tempfile} | grep teardown | awk '{print $2}' \
                     | cut -d "," -f1 | awk '{$1=$1};1')
    for shName in $config_SHN; do
        sed -i -e "s/,${shName}//g" "${tempfile}"
    done
    # Remove config marked as teardown
    sed -i '/teardown/d' "${tempfile}"

    if [ ! -r "${WSPLCD_MAP_BSS_POLICY_PATH}" ] || \
        ! cmp -s "${tempfile}" "${WSPLCD_MAP_BSS_POLICY_PATH}"; then
        # New file differs from old. Move it into place and update
        # the change count.
        mv -f "${tempfile}" "${WSPLCD_MAP_BSS_POLICY_PATH}"
        changed=$((changed + 1))
        eval "$1='$changed'"
    else
        # No change, so just remove the temporary file
        rm -f "${tempfile}"
    fi

    return 0
}

# Switch the device into acting as a gateway connected AP (no bSTA).
#
# Pre-condition: RE mode has already been checked to be SON
#
# input: $1 is_controller: whether the device should act as the controller
#                          or just a gateway connected AP
# input: $2 standalone_controller: if a controller, whether the device should
#                                  act as a standalone controller
__repacd_config_gwcon_map_ap() {
    local is_controller=$1
    local wsplcd_mode son_mode
    local rate_scaling_factor=0
    local default_root_dist=0

    # The WDS, VAP independent, and QWrap AP settings also need to be updated
    # based on the range extension mode.
    local enable_wds=1 enable_multi_ap=1 disable_steering=0
    local deep_clone=0 deep_clone_no_bssid=0 config_sta=0 map_enable=1
    local block_dfs

    __repacd_echo "Using SON mode for GW Connected AP"

    # In WDS/SON modes, we let the OEM customize whether DFS channels
    # should be permitted.
    if __repacd_is_block_dfs; then
        block_dfs=1
    else
        block_dfs=0
    fi

    wsplcd_enabled=1

    local disable_24g_sta disable_5g_sta disable_24g_ap disable_5g_ap
    if [ "$is_controller" -gt 0 ] && [ "$standalone_controller" -gt 0 ]; then
        __repacd_echo "Disabling all interfaces for standalone controller"
        disable_24g_sta=1
        disable_5g_sta=1
        disable_24g_ap=1
        disable_5g_ap=1
    else
        # In GW-connected AP mode, only the AP interfaces are enabled.
        disable_24g_sta=1
        disable_5g_sta=1
        disable_24g_ap=0
        disable_5g_ap=0
    fi
    config_load wireless
    config_foreach __repacd_disable_vap wifi-iface \
        $managed_network 'sta' $disable_24g_sta $disable_5g_sta config_changed
    config_foreach __repacd_disable_vap wifi-iface \
        $managed_network 'ap' $disable_24g_ap $disable_5g_ap config_changed

    # Now set up the interfaces in the right way.
    if [ "$standalone_controller" -eq 0 ]; then
        config_foreach __repacd_config_iface_map wifi-iface \
            $managed_network $block_dfs config_changed
    fi

    uci_commit wireless

    uci_set repacd repacd Role 'CAP'
    if [ "$is_controller" -gt 0 ]; then
        uci_set $MAP MultiAP EnableController 1

        # Standalone controller does not act as an Agent
        if [ "$standalone_controller" -gt 0 ]; then
            uci_set $MAP MultiAP EnableAgent 0
        else
            uci_set $MAP MultiAP EnableAgent 1
        fi

        # Force the remote association tracking on for the controller, as the
        # steering is centralized.
        uci_set $MAPLBD StaDB TrackRemoteAssoc 1
    else
        uci_set $MAP MultiAP EnableController 0
        uci_set $MAP MultiAP EnableAgent 1

        # For an agent, use whatever the current remote association tracking
        # setting is. There is still an advantage to tracking remote
        # associations as it allows the bridging tables to be cleaned up
        # properly when a Topology Notification is missed.
    fi

    if [ "$map_version" -ge 2 ]; then
        __repacd_configure_hyd_map $map_version $is_controller
        config_load wireless
        config_foreach __repacd_disable_vap wifi-iface \
                       $map_backhaul_nw 'sta' $disable_24g_sta $disable_5g_sta config_changed

    fi

    # This generally should nto be needed when operating in gateway connected
    # AP mode. Until there is a case where we need it, we'll leave it disabled.
    uci_set repacd FrontHaulMgr ManageFrontAndBackHaulsIndependently 0
    uci_commit repacd

    uci_commit $MAP
    uci_commit $MAPLBD

    if [ "$is_controller" -gt 0 ]; then
        wsplcd_mode='REGISTRAR'
        son_mode='HYROUTER'

        if ! __repacd_generate_map_bss_conf config_changed; then
            return 1
        fi
    else
        wsplcd_mode='ENROLLEE'
        son_mode='HYCLIENT'
    fi

    # No deep cloning with the MAP algorithms
    __repacd_configure_wsplcd $wsplcd_mode $deep_clone $deep_clone_no_bssid \
                              $config_sta $map_version config_changed

    __repacd_configure_son $enable_wds $disable_steering $enable_multi_ap \
        $son_mode config_changed

    return 0
}

# Switch the device to act as a range extender.
__repacd_config_map_re() {
    # The WDS and QWrap AP settings also need to be updated based on the
    # range extension mode.
    local enable_wds=1 block_dfs
    local enable_multi_ap=1 disable_steering=0
    local deep_clone=0 deep_clone_no_bssid=0 config_sta=0 map_enable=1

    local disable_24g_ap=0 disable_5g_ap=0

    # We let the OEM customize whether DFS channels should be permitted.
    if __repacd_is_block_dfs; then
        block_dfs=1
    else
        block_dfs=0
    fi

    # We let the daemon start wsplcd once it has a stable bSTA association.
    wsplcd_enabled=0
    wsplcd_stop=1

    config_load wireless

    # How the bSTA interface is managed is dependent on the selected and
    # preference values.
    local selected_radio='' preferred_radio=''
    map_bsta_max_preference=0
    config_foreach __repacd_resolve_bsta_radio wifi-device \
        selected_radio preferred_radio

    if [ -z "$selected_radio" ]; then
        selected_radio="$preferred_radio"
    fi

    __repacd_echo "Using $selected_radio for bSTA"
    config_foreach __repacd_update_map_bsta_radio wifi-iface \
                   $selected_radio $managed_network config_changed
    if [ "$map_version" -ge 2 -a "$map_ts_enabled" -eq 1 ]; then
        config_foreach __repacd_update_map_bsta_radio wifi-iface \
                       $selected_radio $map_backhaul_nw config_changed
    fi

    config_foreach __repacd_disable_vap wifi-iface \
        $managed_network 'ap' $disable_24g_ap $disable_5g_ap config_changed

    config_foreach __repacd_config_iface_map wifi-iface \
        $managed_network $block_dfs config_changed

    uci_commit wireless

    uci_set repacd repacd Role 'NonCAP'
    uci_set repacd FrontHaulMgr ManageFrontAndBackHaulsIndependently 1
    uci_commit repacd

    uci_set $MAP MultiAP EnableController 0
    uci_set $MAP MultiAP EnableAgent 1
    uci_commit $MAP

    if [ "$map_version" -ge 2 ]; then
        __repacd_configure_hyd_map $map_version $is_controller
    fi

    __repacd_configure_wsplcd 'ENROLLEE' $deep_clone $deep_clone_no_bssid \
                              $config_sta $map_version config_changed

    __repacd_configure_son $enable_wds $disable_steering $enable_multi_ap \
        'HYCLIENT' config_changed
}

# Restart wsplcd and the Wi-Fi interfaces based on configuration changes.
__repacd_restart_dependencies() {
    if [ "$wsplcd_stop" -gt 0 ]; then
        $WSPLCD_INIT stop
    fi

    if [ "$hyd_stop" -gt 0 ]; then
        $HYD_INIT stop
        $HYFI_BRIDGING_INIT stop
    fi

    # When hyd is being started, start the bridging hooks prior to restarting
    # the network to ensure any temporary loops are prevented.
    if [ "$hyd_start" -gt 0 ]; then
        $HYFI_BRIDGING_INIT start
    fi

    if [ "$config_changed" -gt 0 ]; then
        __repacd_echo "Restarting network stack..."
        whc_network_restart
    else
        __repacd_echo "No changes; not restarting network stack..."
        config_load repacd
        config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
        config_get network_guest repacd NetworkGuest 'guest'
        config_get network_guestmac repacd GuestMac 'ath0'
        if [ "$traffic_separation_enabled" -gt 0 ]; then
            brguest=`ifconfig $network_guestmac | grep HWaddr | awk '{print $5}'`
            ifconfig br-$network_guest hw ether "$brguest"
        fi
    fi

    if [ "$wsplcd_start" -gt 0 ]; then
        __repacd_echo "Starting wsplcd"
        $WSPLCD_INIT start
    elif [ "$wsplcd_restart" -gt 0 ]; then
        __repacd_echo "Restarting wsplcd"
        $WSPLCD_INIT restart
    fi

    if [ "$hyd_start" -gt 0 ]; then
        __repacd_echo "Starting $MAP"
        $HYD_INIT start
    fi
}

__stop_repacd_run() {
    PID=$(ps | grep repacd-run | grep -v grep | awk '{print $1}')
    if [ -n "$PID" ]; then
        kill -s SIGTERM $PID
        __repacd_echo "stopped repacd-run process $PID"
    fi
}

# Perform the startup actions when operating in the original Wi-Fi SON mode
# (no Multi-AP SIG support).
__start_son() {
    local enabled map_enabled device_type
    local mode activate_ts
    local eth_mon_enabled

    config_changed=0
    net_config_changed=0
    activate_ts=0

    config_load 'repacd'
    config_get_bool enabled repacd 'Enable' '0'
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get daisy_chain WiFiLink DaisyChain '0'
    config_get backhaul_ssid repacd BackhaulSSID $def_backhaul_ssid
    config_get backhaul_enc repacd BackhaulEnc $def_backhaul_enc
    config_get backhaul_key repacd BackhaulKey $def_backhaul_key
    config_get network_guest repacd NetworkGuest 'guest'
    config_get guest_ssid repacd GuestSSID $def_guest_ssid
    config_get guest_enc repacd GuestEnc $def_guest_enc
    config_get guest_key repacd GuestKey $def_guest_key
    config_get guest_backhaul_iface repacd NetworkGuestBackhaulInterface 'both'
    config_get eth_mon_enabled repacd 'EnableEthernetMonitoring' '0'
    config_get manage_vap_ind WiFiLink 'ManageVAPInd' '0'
    config_get Manage_front_and_back_hauls_ind 'FrontHaulMgr' 'ManageFrontAndBackHaulsIndependently' '0'
    __repacd_get_config_re_mode config_re_mode

    [ "$enabled" -gt 0 ] || {
        return 1
    }

    __repacd_echo "starting WHC auto-configuration"

    # For now, we can only manage a single network.
    config_get managed_network repacd ManagedNetwork 'lan'
    __repacd_echo "Managed network: $managed_network"

    config_get device_type repacd DeviceType 'RE'
    __repacd_echo "Device type: $device_type"

    # Grab a lock to prevent any updates from being made by the daemon.
    whc_wifi_config_lock

    __repacd_config_wps_pbc_enhc 0 config_changed

    # Config_changed is not being gracefully handled in MIPS.
    # so commiting the change if wps_pbc_enhn is set
    if [ "$config_changed" -gt 0 ]; then
        uci_commit wireless
        config_changed=0
    fi

    if __repacd_vaps_in_default_config; then
        __repacd_reset_default_config
        config_changed=1
        __repacd_echo "Reset $managed_network VAPs"
    else
        # Need to massage the configuration to make it consistent with the
        # expectations of repacd.
        __repacd_reset_existing_config
        __repacd_echo "Initialized $managed_network VAPs"
    fi

    __repacd_enable_wifi

    # create additional vaps if traffic separation enabled
    if __repacd_gw_mode || [ "$device_type" = 'RE' ] && [ "$gwcon_mode" != "CAP" ]; then
        if [ "$traffic_separation_enabled" -gt 0 ]; then
            if __repacd_is_qwrap_mode || \
               __repacd_is_son_mode; then
                if __repacd_check_additional_network_exist; then
                    __repacd_set_bridge_empty $network_guest
                    __repacd_set_firewall_rules $network_guest

                    __repacd_reset_additional_config

                    if ! __repacd_gw_mode && __repacd_is_qwrap_mode && \
                       [ "$traffic_separation_active" -eq 0 ]; then
                        local disable_24g_ap=1 disable_5g_ap=1

                        config_load wireless
                        config_foreach __repacd_disable_vap wifi-iface \
                            $network_backhaul 'ap' $disable_24g_ap $disable_5g_ap config_changed
                        config_foreach __repacd_disable_vap wifi-iface \
                            $network_guest 'ap' $disable_24g_ap $disable_5g_ap config_changed
                        uci_commit wireless
                    fi

                    uci_set repacd repacd NetworkBackhaul $network_backhaul
                    uci_commit repacd
                    activate_ts=1
                fi
            fi
        fi
    fi

    if __repacd_gw_mode; then
        # WAN group not empty; this device will act as CAP regardless of
        # the GatewayConnectedMode setting
        __repacd_config_gwcon_ap_mode 1
    elif [ "$device_type" = 'RE' ]; then
        # WAN group empty or non-existent
        # Switch to range extender mode

        # Clear the BSSIDs on fresh restart
        config_load wireless
        if [ "$traffic_separation_active" -gt 0 ]; then
            config_foreach __repacd_delete_bssid_entry wifi-iface $network_backhaul config_changed
        else
            config_foreach __repacd_delete_bssid_entry wifi-iface $managed_network config_changed
        fi
        uci_set repacd WiFiLink BSSIDResolveState 'resolving'
        uci_commit wireless
        uci_commit repacd
        __repacd_config_re_mode

        if [ "$activate_ts" -eq 1 ]; then
                config_load wireless
                config_foreach __repacd_reconfig_sta_vaps wifi-iface $managed_network $network_backhaul \
                    "$backhaul_ssid" "$backhaul_enc" "$backhaul_key"
                uci_commit wireless
        fi
    else
        # Must be a client device (that can opportunistically act as an RE).
        __repacd_config_client_mode
    fi


    whc_wifi_config_unlock

    __repacd_restart_dependencies
   if [ "$traffic_separation_enabled" -gt 0 ]; then
        __repacd_wifi_set_otherband_bssids $network_backhaul
   else
        __repacd_wifi_set_otherband_bssids $managed_network
   fi

    # create vlan interfaces required for traffic separation.
    if [ "$activate_ts" -eq 1 ]; then
            config_load network
            config_load wireless
            config_foreach __repacd_add_vlan_interfaces wifi-iface \
                $managed_network $lan_vid 'both' net_config_changed
            config_foreach __repacd_add_vlan_interfaces wifi-iface \
                $network_guest $guest_vid $guest_backhaul_iface net_config_changed
            uci_commit wireless

            __repacd_add_ethernet_vlan_interfaces $network_guest net_config_changed
            uci_commit network

            __repacd_restart_firewall

            uci_set repacd repacd TrafficSeparationActive '1'
            uci_commit repacd

            # stop/start hyd only if there is any change in netwrok config
            # due to addition of VLAN interfaces. If required VLAN iface already
            # present then we can avoid hyd stop/start. This will save some time
            # and avoid any delays after repacd restart.
            if [ "$net_config_changed" -gt 0 ] || [ "$config_changed" -gt 0 ]; then
                config_changed=0
                hyd_stop=1
                hyd_start=1
                wsplcd_stop=1
                wsplcd_start=1
                __repacd_restart_dependencies
            fi
    fi

    if [ "$eth_mon_enabled" -eq 1 ]; then
        # Make sure lldpd listens on wan and lan interfaces
        for int in wan lan; do
            if ! uci get lldpd.config.interface | grep $int > /dev/null; then
                uci add_list lldpd.config.interface=$int
            fi
        done
        __repacd_echo "Starting lldpd"
        repacd_netdet_lldpd_init start
    fi

    if ! __repacd_gw_mode || [ "$eth_mon_enabled" -eq 1 ]; then
        __stop_repacd_run

        # Start the script that monitors the link state.
        #
        # When in NonCAP mode, it will keep checking whether there is a link
        # to the gateway over ethernet. When in CAP mode, it will keep
        # checking the WAN/LAN ifaces.
        __repacd_echo "Starting  RE Placement and Auto-config Daemon"
        start-stop-daemon -S -x /usr/sbin/repacd-run.sh -b -- \
            "son" init $config_re_mode $resolved_re_mode $resolved_re_submode
    fi
}

# Perform the startup actions when operating with Multi-AP SIG Topology
# Optimization.
#
# Pre-condition: repacd has already been determined to be enabled and in
#                MAP mode
#
# input: $1 - ether_gwcon: whether the device has been determined to be
#                          connected to the gateway via Ethernet
# input: $2 - start_role: the startup role for the device
# input: $3 - autoconf: boolean indicating whether this was a start
#                       initiated due to an auto config change
__start_map() {
    local ether_gwcon=$1
    local start_role=$2
    local autoconf=$3

    local enabled gwcon_mode first_config_required manage_mcsd
    local traffic_separation_enabled ethernet_monitoring_enabled
    local enable_steering standalone_controller

    config_changed=0
    map_dpp_enabled=0
    dpp_sta_found=0

    config_load 'repacd'
    config_get_bool enabled repacd 'Enable' '0'
    config_get gwcon_mode repacd GatewayConnectedMode 'AP'
    config_get_bool first_config_required MAPConfig 'FirstConfigRequired' '0'
    config_get_bool manage_mcsd repacd 'ManageMCSD' 1
    config_get_bool standalone_controller MAPConfig 'StandaloneController' '0'
    config_get map_country MAPConfig 'MapCountry'
    config_get map_single_r1r2_bh MAPConfig 'CombinedR1R2Backhaul'

    # Certain features are not supported with Multi-AP (at least not yet)
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get ethernet_monitoring_enabled repacd EnableEthernetMonitoring '0'
    config_get enable_steering repacd EnableSteering '1'

    # Config required for EasyMesh Rev2 Traffic Separation
    config_get map_version MAPConfig 'MapVersionEnabled' '1'
    config_get num_vlan_supported MAPConfig 'NumberOfVLANSupported' '0'
    config_get map_ts_enabled MAPConfig 'MapTrafficSeparationEnable' '0'
    config_get map_primary_nw MAPConfig 'VlanNetworkPrimary' ''
    config_get map_backhaul_nw MAPConfig 'VlanNetworkBackHaul' ''

    # Config Required for DPP
    config_get onboarding_type MAPConfig 'OnboardingType'
    config_get dump_security_logs MAPConfig 'DPPDumpSecurityLog' '0'

    if [ "$onboarding_type" == "dpp" ]; then
        map_dpp_enabled=1
    else
        map_dpp_enabled=0

        config_load $MAP
        uci_set $MAP MAPConfigSettings 'EnableConfigService' 0
        uci_set $MAP MultiAP 'Enable1905Security' 1
        uci_set $MAP MAPConfigSettings 'MapOnboardingType' 'none'
        uci_set $MAP MAPConfigSettings 'MapConfigDumpToFile' 0
        uci_set $MAP MAPConfigSettings 'DebugLevel' 0
        uci_commit $MAP
    fi

    if ! __repacd_is_son_mode; then
        __repacd_echo "Multi-AP SIG algorithms must use 'son' RE mode"
        return 1
    fi

    if [ "$traffic_separation_enabled" -gt 0 ]; then
        __repacd_echo "Traffic separation not supported with Multi-AP SIG" \
                      "Topology Optimization"
        return 1
    fi

    if [ "$ethernet_monitoring_enabled" -gt 0 ]; then
        __repacd_echo "Ethernet monitoring not supported with Multi-AP SIG" \
                      "Topology Optimization"
        return 1
    fi

    if [ "$enable_steering" -eq 0 ]; then
        __repacd_echo "Steering must be enabled with Multi-AP SIG" \
                      "Topology Optimization"
        return 1
    fi

    __repacd_echo "Starting Multi-AP SIG auto-configuration"
    __repacd_echo "Ethernet connection to GW=$ether_gwcon"
    __repacd_echo "GW Connected Mode=$gwcon_mode"
    __repacd_echo "MAP Version: $map_version"
    __repacd_echo "Num VLAN Supported: $num_vlan_supported"
    __repacd_echo "Combined R1 and R2 backhaul: $map_single_r1r2_bh"
    __repacd_echo "Onboarding Type : $onboarding_type"
    __repacd_echo "Dump Hostapd , supplicant and config service debug logs : $dump_security_logs"

    if [ "$onboarding_type" == "dpp" -a "$dump_security_logs" -eq 1 \
                            -a "$first_config_required" -gt 0 ]; then
        rm /tmp/hostapd.log
        rm /tmp/supplicant.log

        uci_set $MAP hy 'breakPadEnabled' '1'
        hostapdPID=$(ps | grep hostapd/global | grep -v grep | awk '{print$1}')
        suppPID=$(ps | grep wpa_supplicantglobal | grep -v grep | awk '{print$1}')
        kill $hostapdPID
        kill $suppPID
        wpa_supplicant -g /var/run/wpa_supplicantglobal -ddddK -f /tmp/supplicant.log &
        hostapd -g /var/run/hostapd/global -P /var/run/hostapd-global.pid \
                -ddddK -f /tmp/hostapd.log &
    fi

    # For now, we can only manage a single network.
    config_get managed_network repacd ManagedNetwork 'lan'
    __repacd_echo "Managed network: $managed_network"

    local is_controller=0
    if __repacd_gw_mode || [ "$gwcon_mode" = 'Controller' ]; then
        # WAN group not empty; this device will act as controller regardless of
        # the GatewayConnectedMode setting
        is_controller=1
    fi

    # Grab a lock to prevent any updates from being made by the daemon.
    whc_wifi_config_lock

    # Since the controller could tear down all AP interfaces, we need to
    # allow hyd to run with no interfaces.
    uci_set $MAPLBD config_Adv 'AllowZeroAPInterfaces' 1

    # Also disable IAS on both bands, as we do not yet have the messaging
    # support for it & set the Forwading mode by default to SINGLE for MAP.
    uci_set $MAPLBD IAS 'Enable_W2' 0
    uci_set $MAPLBD IAS 'Enable_W5' 0
    uci_set $MAP hy 'ForwardingMode' 'SINGLE'
    uci_commit $MAPLBD
    uci_commit $MAP

    uci_set $MAP MultiAP 'MapVersion' $map_version
    uci_commit $MAP
    # Disable the DBDC repeater feature on all devices, as there will only
    # ever be a single backhaul STA interface.
    config_load wireless
    config_foreach __repacd_config_dbdc_device wifi-device \
                   0 config_changed

    if [ "$map_version" -ge 2 ]; then
        # Stop instance of repacd that is already running
        __stop_repacd_run
        __repacd_map_reset_default_bridge_config $is_controller
    fi

    # Set country to global on all devices
    config_load wireless
    config_foreach __repacd_config_set_device_country wifi-device $map_country

    # Skip auto config for standalone controller, which must be manually configured
    if [ "$first_config_required" -gt 0 ] && [ "$standalone_controller" -eq 0 ]; then
        __repacd_reset_map_default_config $is_controller
        config_changed=1
        uci_set repacd MAPConfig 'FirstConfigRequired' 0

        __repacd_echo "Performed initial config on $managed_network VAPs"
    fi

    if __repacd_gw_mode || [ "$ether_gwcon" -gt 0 ]; then
        if !  __repacd_config_gwcon_map_ap $is_controller $standalone_controller; then
            return 1
        fi
    else
        # WAN group empty or non-existent
        # Switch to agent mode
        __repacd_config_map_re
    fi

    local enable_son=1
    __repacd_config_mcsd "$manage_mcsd" "$enable_son"

    whc_wifi_config_unlock

    __repacd_restart_dependencies

    if [ "$map_version" -ge 2 ]; then
        if [ "$map_ts_enabled" -gt 0 ]; then
            if [ "$is_controller" -gt 0 ]; then
                __repacd_map_apply_vlan_config
            fi

            # Set bridge MAC
            __repacd_map_set_bridge_mac
            ubus call network reload
        fi

        if [ "$map_version" -ge 3 -a "$map_dpp_enabled" -eq 1 ]; then
            # Delete temp files
            rm /tmp/map_key_info.tmp
            rm /tmp/mapConfig.log

            # Get Configurator key if already present
            dpp_config_key=$(uci get $MAP.MAPConfigSettings.DPPConfiguratorKey)
            dpp_key_len=${#dpp_config_key}

            if [ "$is_controller" -eq 1 ]; then
                __repacd_set_map_dpp_config $is_controller $start_role
            fi

            if [ "$is_controller" -eq 0 ]; then
                config_load wireless
                config_foreach __repacd_get_map_sta_iface wifi-iface

                __repacd_set_map_dpp_config $is_controller $start_role
            fi
        fi

        # stop/start hyd only if there is any change in network config
        # due to addition of VLAN interfaces. If required VLAN iface already
        # present then we can avoid hyd stop/start. This will save some time
        # and avoid any delays after repacd restart.
        if [ "$net_config_changed" -gt 0 ] || [ "$config_changed" -gt 0 ]; then
            config_changed=0
            hyd_stop=1
            hyd_start=1
            wsplcd_stop=1
            wsplcd_start=1
            __repacd_restart_dependencies
        fi
    fi

    if ! __repacd_gw_mode; then
        __stop_repacd_run

        # Transform the boolean value into what the daemon expects
        if [ "$autoconf" -gt 0 ]; then
            autoconf='autoconf'
        else
            autoconf=''
        fi

        # Start the script that monitors the link state.
        #
        # In this NonCAP mode, it will keep checking whether there is a link
        # to the gateway over ethernet.
        __repacd_echo "Starting  RE Placement and Auto-config Daemon"
        start-stop-daemon -S -x /usr/sbin/repacd-run.sh -b -- \
            "map" "$start_role" $config_re_mode $resolved_re_mode \
            $resolved_re_submode $autoconf
    fi
}

# Get STA iface
__repacd_get_map_sta_iface() {
    local config="$1"
    local iface disabled mode my_bootstrap sta_iface

    config_load $MAP
    config_get dpp_config_key MAPConfigSettings 'DPPConfiguratorKey' '0'

    config_load repacd
    config_get iface "$config" ifname
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode

    if [ -n "$iface" -a "$disabled" -eq 0 -a "$mode" = "sta" ]; then
        sta_iface=$iface
        dpp_sta_found=1

        if [ -z "$sta_iface" ]; then
            __repacd_echo "STA iface invalid"
        fi

        __repacd_echo "STA iface $sta_iface"

        # Get Key
        if [ "$dpp_key_len" -eq 0 ]; then
            wpa_cli -p /var/run/wpa_supplicant-$sta_iface dpp_configurator_remove '*'
            wpa_cli -p /var/run/wpa_supplicant-$sta_iface dpp_configurator_add curve=P-256
            dpp_config_key=$(wpa_cli -p /var/run/wpa_supplicant-$sta_iface \
                                     dpp_configurator_get_key 1 | grep 30770)
        fi

        # Generate BootStrap
        # wpa_cli -p /var/run/wpa_supplicant-$sta_iface dpp_bootstrap_remove '*'
        wpa_cli -p /var/run/wpa_supplicant-$sta_iface dpp_bootstrap_gen type=qrcode \
                key=$dpp_config_key
        wpa_cli -p /var/run/wpa_supplicant-$sta_iface dpp_bootstrap_info 1

        my_bootstrap=$(wpa_cli -p /var/run/wpa_supplicant-$sta_iface dpp_bootstrap_get_uri 1 \
                           | grep DPP)

        rm /tmp/map_bootstrap_info.tmp
        echo $my_bootstrap > /tmp/map_bootstrap_info.tmp

        uci_set wireless "$config" dpp_key "$dpp_config_key"
        uci_commit wireless

        uci_set $MAP MAPConfigSettings 'DPPConfiguratorKey' $dpp_config_key
        uci_commit $MAP
    fi
}

# Set dpp_key on AP iface
__repacd_set_dpp_key_ap_iface() {
    local config="$1"
    local key="$2"
    local iface disabled mode

    config_get iface "$config" ifname
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode

    if [ -n "$iface" -a "$disabled" -eq 0 -a "$mode" = "ap" ]; then
        uci_set wireless "$config" dpp_key "$key"
        uci_commit wireless
    fi
}

# Setup dpp on controller and agent
# input: $1 - is_controller: whether this device is acting as the controller
# input: $2 - start_role: start role for device
__repacd_set_map_dpp_config() {
    local is_controller=$1
    local start_role=$2
    local dump_security_logs enable_cs_logs

    config_load repacd
    config_get enable_cs_logs MAPConfig 'EnableConfigServiceLogs' '0'
    config_get dump_security_logs MAPConfig 'DPPDumpSecurityLog' '0'

    __repacd_echo "DPP Key : $dpp_config_key"
    __repacd_echo "DPP Key Len: $dpp_key_len"

    uci_set $MAP MAPConfigSettings 'EnableConfigService' 1
    if [ "$start_role" == "NonCAP" -o "$start_role" == "RE" ]; then
        uci_set $MAP MAPConfigSettings 'EnableConfigService' 0
    fi
    uci_set $MAP MultiAP 'Enable1905Security' 1
    uci_set $MAP MAPConfigSettings 'MapEProfile' 'generic'
    uci_set $MAP MAPConfigSettings 'MapOnboardingType' 'dpp'
    uci_set $MAP MAPConfigSettings 'MapConfigDumpToFile' $enable_cs_logs
    uci_set $MAP MAPConfigSettings 'DebugLevel' 0

    if [ "$enable_cs_logs" -eq 1 -a "$dump_security_logs" -eq 0 ]; then
        uci_set $MAP MAPConfigSettings 'DebugLevel' 1
    fi
    if [ "$enable_cs_logs" -eq 1 -a "$dump_security_logs" -eq 1 ]; then
        uci_set $MAP MAPConfigSettings 'DebugLevel' 2
    fi

    # Start controller socket on hostapd
    hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_controller_start tcp_port=7999

    # Controller Config
    if [ "$is_controller" -eq 1 ]; then
        if [ "$dpp_key_len" -eq 0 ]; then
            # Get Key
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_remove '*'
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_add curve=P-256
            dpp_config_key=$(hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 \
                                         dpp_configurator_get_key 1)
        fi

        # Get CSIGN JWK
        hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_map_get_jwk_csign curve=P-256 \
                    key=$dpp_config_key

        uci_set $MAP MAPConfigSettings 'RoleController' 1
        uci_set $MAP MAPConfigSettings 'RoleAgent' 0
        uci_set $MAP MAPConfigSettings 'DPPConfiguratorKey' $dpp_config_key
        uci_commit $MAP
    fi

    # Agent Config
    if [ "$is_controller" -eq 0 ]; then
        __repacd_echo "Configure DPP Agent"
        if [ "$dpp_sta_found" -eq 0 ]; then
            __repacd_echo "Configure Ethernet Agent"

            if [ "$dpp_key_len" -eq 0 ]; then
                # Get Key
                hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_remove '*'
                hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_add curve=P-256
                dpp_config_key=$(hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 \
                                             dpp_configurator_get_key 1)
            fi

            # Bootstrap Gen
            # hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_bootstrap_remove '*'
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_bootstrap_gen type=qrcode \
                        key=$dpp_config_key
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_bootstrap_info 1
            my_bootstrap=$(hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_bootstrap_get_uri 1)

            #rm /tmp/map_bootstrap_info.tmp
            echo $my_bootstrap > /tmp/map_bootstrap_info.tmp
            uci_set $MAP MAPConfigSettings 'DPPConfiguratorKey' $dpp_config_key

            config_load wireless
            config_foreach __repacd_set_dpp_key_ap_iface wifi-iface $dpp_config_key
        fi

        uci_set $MAP MAPConfigSettings 'RoleController' 0
        uci_set $MAP MAPConfigSettings 'RoleAgent' 1
        uci_commit $MAP
    fi
}

__repacd_config_set_default_maplite_vap_param() {
    local vapIdx=$1
    uci set wireless.@wifi-iface[$vapIdx].encryption='psk2+ccmp'
    uci set wireless.@wifi-iface[$vapIdx].key=maplite-123
    uci set wireless.@wifi-iface[$vapIdx].wps_pbc=1
    uci set wireless.@wifi-iface[$vapIdx].wps_pbc_enable=1
    uci set wireless.@wifi-iface[$vapIdx].wps_pbs_start_time=0
    uci set wireless.@wifi-iface[$vapIdx].wps_pbs_duration=120
    uci set wireless.@wifi-iface[$vapIdx].dpp_configurator_connectivity=1
    uci set wireless.@wifi-iface[$vapIdx].dpp_map=1
    uci set wireless.@wifi-iface[$vapIdx].map=$map_version
    uci commit wireless
}

# Delete all of the VAPs for the given network that are marked as unmanaged.
#
# input: $1 config: section being considered
# input: $2 mode: ap or sta
__repacd_delete_managed_maplite_vaps() {
    local config="$1"
    local network repacd_security_unmanaged mode

    config_get network "$config" network
    config_get mode "$config" mode
    config_get device "$config" device

    if [ $mode = "ap_smart_monitor" -o $mode = "$2" ]; then
        uci delete "wireless.$config"
    fi

    if [ "$3" = "$network" -a "$4" != "$device" ]; then
        uci delete "wireless.$config"
    fi
}

# Perform the startup actions when operating MAP Lite Mode
# (Plug Fest Mode).
__start_map_lite() {
    kill $repacdPID
    local unicast_flood_disable
    local hostapdPID suppPID
    local bh_type sta_device
    local onboarding_type

    wifimeshconfig map

    __repacd_echo "Starting Multi-AP Lite Mode"
    config_get dev_reset_default MAPConfig 'MapDevResetDefault' '0'
    config_get deviceMode MAPConfig 'MapDeviceMode'
    config_get num_vlan_supported MAPConfig 'NumberOfVLANSupported' '0'
    config_get map_version MAPConfig 'MapVersionEnabled'
    config_get num_vlan_supported MAPConfig 'NumberOfVLANSupported' '0'
    config_get map_primary_nw MAPConfig 'VlanNetworkPrimary' ''
    config_get map_backhaul_nw MAPConfig 'VlanNetworkBackHaul' ''
    config_get map_single_r1r2_bh MAPConfig 'CombinedR1R2Backhaul'
    config_get map_country MAPConfig 'MapCountry'
    config_get bh_type MAPConfig 'MapBackaulType'
    config_get sta_device MAPConfig 'MapSTARadio'
    config_get my_key MAPConfig 'DPPKey'
    config_get my_bootstrap MAPConfig 'DPPMyBootstrap'
    config_get onboarding_type MAPConfig 'OnboardingType'
    map_dpp_enabled=0
    map_ts_enabled=1
    unicast_flood_disable=1

    __repacd_echo "dev_reset_default: $dev_reset_default"
    __repacd_echo "MAP device Mode: $deviceMode"
    __repacd_echo "MAP Version: $map_version"
    __repacd_echo "Num VLAN Supported: $num_vlan_supported"
    __repacd_echo "DPP Enabled: $map_dpp_enabled"
    __repacd_echo "Backhaul Type: $bh_type"
    __repacd_echo "sta_device: $sta_device"
    __repacd_echo "My Bootstrap : $my_bootstrap"
    __repacd_echo "Onboarding Type : $onboarding_type"

    if [ "$onboarding_type" == "dpp" ]; then
        map_dpp_enabled=1
    fi

    # Set country to global on all devices
    config_load wireless
    config_foreach __repacd_config_set_device_country wifi-device $map_country

    if [ "$dev_reset_default" -eq 1 ]; then
        __repacd_map_reset_default_bridge_config

        if [ "$map_version" -ge 3 ]; then
            kill $repacdPID

            rm /tmp/hostapd.log
            rm /tmp/supplicant.log
            rm /tmp/map_bootstrap_info.tmp
            rm /tmp/map_peer_bootstrap_info.tmp
            rm /tmp/map_key_info.tmp
            rm /tmp/map_bh_info.tmp
            rm /tmp/map_fh_info.tmp
            rm /tmp/ptk.txt
            rm /tmp/pmk.txt
            rm /tmp/map_dpp_bsta_agent_info.tmp
            rm /tmp/hyd.log
            rm /tmp/mapConfig.log
            hostapdPID=$(ps | grep hostapd/global | grep -v grep | awk '{print$1}')
            suppPID=$(ps | grep wpa_supplicantglobal | grep -v grep | awk '{print$1}')
            kill $hostapdPID
            kill $suppPID
            wpa_supplicant -g /var/run/wpa_supplicantglobal -ddddK -f /tmp/supplicant.log &
            hostapd -g /var/run/hostapd/global -P /var/run/hostapd-global.pid \
                    -ddddK -f /tmp/hostapd.log &

           # Enable Radio
           config_load wireless
           config_foreach __repacd_config_set_radio_enable wifi-device
           __repacd_echo "Num radio $map_num_radio"

           for i in 0 1 2 3 4 5; do
               if [ "$i" -lt "$map_num_radio" ]; then
                   __repacd_config_set_default_maplite_vap_param $i
               fi
           done

           # Reset Configs
           uci_set $MAP MAPConfigSettings 'EnableConfigService' 0
           uci_set $MAP MAPConfigSettings 'RoleController' 0
           uci_set $MAP MAPConfigSettings 'RoleAgent' 0
           uci_set $MAP MAPConfigSettings 'MapOnboardingType' 'legacy'
        fi

        config_load wsplcd
        config_load $MAP
        config_load mcsd

        # Common config to CAP and Agent
        uci_set $MAP MultiAP 'EnableSigmaDUT' 1
        uci_set $MAP MultiAP 'MapPFCompliant' 1
        uci_set $MAP MultiAP 'MapVersion' $map_version
        # Set Forwarding Mode to SINGLE to disable HA, HD
        uci_set $MAP hy 'ForwardingMode' 'SINGLE'

        uci_set wsplcd config 'ConfigSta' 0
        uci_set wsplcd config 'DeepClone' 0
        uci_set wsplcd config 'DebugLevel' "DUMP"
        uci_set wsplcd config 'WriteDebugLogToFile' "TRUNCATE"
        uci_set wsplcd config 'MapMaxBss' 4
        uci_set wsplcd config 'ManageVAPInd' 0
        uci_set wsplcd config 'MapPFCompliant' 1
        uci_set wsplcd config 'MapEnable' $map_version

        uci_set mcsd config 'Enable' 0

        if [ "$map_version" -ge 2 ]; then
            config_load 'repacd'
            uci_set repacd MAPConfig 'EnableMapTSLogs' '1'
            uci_set repacd MAPConfig 'MapTrafficSeparationEnable' '1'
            uci_set repacd repacd 'EnableMixedBackhaul' '1'
            uci_set repacd MAPConfig 'TSUseSameBridgeMAC' '0'

            uci_set $MAP MultiAP 'NumberOfVLANSupported' $num_vlan_supported
            uci_set $MAP MultiAP 'Map2TrafficSepEnabled' 1
            uci_set $MAP MultiAP 'CombinedR1R2Backhaul' $map_single_r1r2_bh
            uci_set $MAP MultiAP 'VlanNetworkPrimary' $map_primary_nw
            uci_set wsplcd config 'NumberOfVLANSupported' $num_vlan_supported
            uci_set wsplcd config 'Map2TrafficSepEnabled' 1
            uci_set wsplcd config 'CombinedR1R2Backhaul' $map_single_r1r2_bh
        fi

        if [ "$map_version" -ge 3 ]; then
            uci_set $MAP MAPSPSettings 'EnableSP' '1'
            uci_set $MAP MAPSPSettings 'EnableEnhancedSP' '1'
            uci_set $MAP MAPSPSettings 'MaxSPRules' '10'
            uci_set $MAP hy 'breakPadEnabled' '1'

            #ecm is disabled for now for lite mode of operation
            /etc/init.d/qca-nss-ecm stop
            sysctl -w net.bridge.bridge-nf-call-iptables=1
            ssdk_sh fdb learnctrl set disable
            ssdk_sh fdb entry flush 1
            sleep 1

            #Service prioritzation enabled
            echo 1 > /proc/sys/net/emesh-sp/enable
        fi

        if  [ "$deviceMode" = "CAP" ]; then
            # Set HYD Parameters
            uci_set $MAP config 'Mode' "HYROUTER"
            uci_set $MAP MultiAP 'EnableController' 1
            # Set WSPLCD Parameters
            uci_set wsplcd config 'RunMode' "REGISTRAR"
        else
            # Set HYD Parameters
            uci_set $MAP config 'Mode' "HYCLIENT"
            uci_set $MAP MultiAP 'EnableAgent' 1
            # Set WSPLCD Parameters
            uci_set wsplcd config 'RunMode' "ENROLLEE"
            uci_set wsplcd config 'Map2EnableMboOcePmf' '1'
            # keeping channel scan interval to R2 only as we do not need
            # it in R3
            if [ "$map_version" -eq 2 ]; then
                uci_set $MAP MultiAP 'ChanScanIntervalMin' 1
                uci_set $MAP MultiAP 'EnableBootOnlyScan' 0
            fi
        fi

        uci_commit $MAP
        uci_commit wsplcd
        uci_commit mcsd

        /etc/init.d/mcsd stop
        /etc/init.d/mcsd disable

        __repacd_map_set_bridge_mac
        /etc/init.d/hyfi-bridging start

        whc_network_restart
        sleep 2

        if  [ "$map_version" -ge 3 -a "$deviceMode" != "CAP" ]; then
            return
        fi
    fi

    if [ "$map_version" -ge 3 -a "$map_dpp_enabled" -eq 0 -a "$dev_reset_default" -eq 0 ]; then
        if [ "$bh_type" = "eth" ]; then
            uci set wireless.qcawifi=qcawifi
            uci set wireless.qcawifi.dp_tx_allow_per_pkt_vdev_id_check=1
            uci commit
            wifi unload
            wifi load
        fi

        if [ "$bh_type" = "wifi" -a "$deviceMode" != "CAP" ]; then
            wifi load
        fi
    fi

    if [ "$map_version" -ge 3 -a "$map_dpp_enabled" -eq 1 ]; then
        uci_set $MAP MultiAP 'Enable1905Security' 1
        uci_set $MAP MAPConfigSettings 'EnableConfigService' 1
        uci_set $MAP MAPConfigSettings 'MapConfigDumpToFile' 1
        uci_set $MAP MAPConfigSettings 'DebugLevel' 1
        uci_set $MAP MAPConfigSettings 'MapEProfile' 'ALSpecific'
        uci_set $MAP MAPConfigSettings 'MapOnboardingType' 'dpp'
        uci_commit $MAP

        # Disable wsplcd for DPP
        /etc/init.d/wsplcd stop
        /etc/init.d/wsplcd disable

        # DPP Setting for CAP . dev reset = 2 means Setting Peer Bootstrap
        if  [ "$dev_reset_default" -eq 2 -a "$deviceMode" = "CAP" ]; then
            # Get Key
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_remove 1
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_add curve=P-256
            key=$(hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_get_key 1)

            # Get CSIGN JWK
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_map_get_jwk_csign curve=P-256 key=$key

            # Start controller socket on hostapd
            hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_controller_start tcp_port=7999

            uci_set $MAP MAPConfigSettings 'RoleController' 1
            uci_set $MAP MAPConfigSettings 'RoleAgent' 0
            uci_set $MAP MAPConfigSettings 'DPPConfiguratorKey' $key
            uci_set $MAP MAPConfigSettings 'DPPMyBootstrap' $my_bootstrap
            uci_commit $MAP
            /etc/init.d/$MAP restart
        fi

        # DPP setting for RE
        if [ "$dev_reset_default" -eq 0 -a "$deviceMode" != "CAP" ]; then
            if [ "$bh_type" = "wifi" ]; then
                config_load wireless
                config_foreach __repacd_delete_managed_maplite_vaps wifi-iface sta

                uci add wireless wifi-iface
                uci set wireless.@wifi-iface[3].device=$sta_device
                uci set wireless.@wifi-iface[3].network=lan
                uci set wireless.@wifi-iface[3].mode=sta
                uci set wireless.@wifi-iface[3].ssid=maplite
                uci set wireless.@wifi-iface[3].encryption='none'
                uci set wireless.@wifi-iface[3].dpp=1
                uci set wireless.@wifi-iface[3].wds=1
                uci set wireless.@wifi-iface[3].map=3
                uci set wireless.@wifi-iface[3].MapBSSType=128
                uci set wireless.@wifi-iface[3].dpp_key=$my_key
                uci set wireless.@wifi-iface[3].dpp_map=1
                uci commit wireless
                wifi load
            fi

            if [ "$bh_type" = "eth" ]; then
                /etc/init.d/hyfi-bridging start
                /etc/init.d/hyfi-bridging restart
                /etc/init.d/$MAP restart

                # Get Key
                hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_remove 1
                hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_add curve=P-256
                my_key=$(hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_configurator_get_key 1)

                # Start controller socket on hostapd
                hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_controller_start tcp_port=7999
                hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_bootstrap_gen type=qrcode \
                            key=$my_key
                hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_bootstrap_info 1
                my_bootstrap=$(hostapd_cli -i ath0 -p /var/run/hostapd-wifi0 dpp_bootstrap_get_uri 1)
            fi

            rm /tmp/map_bootstrap_info.tmp
            echo $my_bootstrap > /tmp/map_bootstrap_info.tmp
            uci_set $MAP MAPConfigSettings 'RoleController' 0
            uci_set $MAP MAPConfigSettings 'RoleAgent' 1
            uci_set $MAP MAPConfigSettings 'DPPConfiguratorKey' $my_key
            uci_set $MAP MAPConfigSettings 'DPPMyBootstrap' $my_bootstrap
            uci_commit $MAP
            /etc/init.d/$MAP restart
        fi
    fi

    if  [ "$deviceMode" != "CAP" ]; then
        kill $repacdPID

        # Start the script that monitors the link state.
        #
        # When in NonCAP mode, it will keep checking whether there is a link
        # to the gateway over ethernet. When in CAP mode, it will keep
        # checking the WAN/LAN ifaces.
        __repacd_echo "Starting MAP Lite RE Daemon"
        start-stop-daemon -S -x /usr/sbin/repacd-run.sh -b -- \
                          "maplite" "init" "maplite" "maplite" "maplite"

    fi
}

# Reset the count of the number of times the 5 GHz bSTA was attempted.
# This should only be invoked on boot and when switching between roles
# (eg. to CAP).
__repacd_map_reset_5g_attempts() {
    uci_set repacd 'MAPWiFiLink' '5gAttemptsCount' 0
    uci_commit repacd
}

# Script entry point: Perform configuration and start the daemon
start() {
    local enabled

    config_load 'repacd'
    config_get_bool enabled repacd 'Enable' '0'

    [ "$enabled" -gt 0 ] || {
        return 1
    }

    if __repacd_is_map_enabled; then

        if __repacd_is_map_lite_enabled; then
            __start_map_lite
            return $?
        fi

        __repacd_map_reset_5g_attempts

        local ether_gwcon=0 start_role='init' autoconf=0
        __start_map $ether_gwcon $start_role $autoconf
        return $?
    else
        __start_son
        return $?
    fi
}

# Script entry point: Stop the daemon
stop() {
    __stop_repacd_run
}

# Script entry point: Reconfigure and restart the daemon
restart() {
    stop

    config_load 'repacd'
    config_get_bool enabled repacd 'Enable' '0'

    [ "$enabled" -gt 0 ] || {
            return 1
    }

    start
}

# Force a restart into CAP mode using the SON algorithms.
#
# @see restart_in_cap_mode
__restart_in_cap_mode_son() {
    local gwcon_mode device_type activate_ts
    config_load repacd
    config_get managed_network repacd ManagedNetwork 'lan'
    config_get gwcon_mode repacd GatewayConnectedMode 'AP'
    config_get device_type repacd DeviceType 'RE'
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get daisy_chain WiFiLink DaisyChain '0'
    config_get backhaul_ssid repacd BackhaulSSID $def_backhaul_ssid
    config_get backhaul_enc repacd BackhaulEnc $def_backhaul_enc
    config_get backhaul_key repacd BackhaulKey $def_backhaul_key
    config_get network_guest repacd NetworkGuest 'guest'
    config_get guest_ssid repacd GuestSSID $def_guest_ssid
    config_get guest_enc repacd GuestEnc $def_guest_enc
    config_get guest_key repacd GuestKey $def_guest_key
    config_get guest_backhaul_iface repacd NetworkGuestBackhaulInterface 'both'
    config_get manage_vap_ind WiFiLink 'ManageVAPInd' '0'
    __repacd_get_config_re_mode config_re_mode
    activate_ts=0
    net_config_changed=0

    stop

    if [ "$gwcon_mode" = "CAP" ]; then
        # Explicitly being forced into CAP mode while gateway connected.
        # This could be a case where a device is being used as a pure bridge
        # due to another device acting as the gateway.
        __repacd_config_wps_pbc_enhc 1 config_changed
        __repacd_config_gwcon_ap_mode 1
    else
        # Operate just as a standalone AP. This assumes there is another
        # device in the network that operates as CAP.
        __repacd_config_wps_pbc_enhc 0 config_changed
        __repacd_config_gwcon_ap_mode 0
    fi

    __repacd_reset_existing_config

    if [ "$traffic_separation_active" -gt 0 ]; then
        config_foreach __repacd_delete_bssid wifi-iface \
            $network_backhaul
    else
        config_foreach __repacd_delete_bssid wifi-iface \
            $managed_network
    fi

    if [ "$device_type" = 'RE' ] && [ "$gwcon_mode" != "CAP" ]; then
        if [ "$traffic_separation_enabled" -gt 0 ] && \
           __repacd_is_son_mode; then
            if __repacd_check_additional_network_exist; then
                # reset additional vaps if traffic separation enabled
                local disable_24g_ap=0 disable_5g_ap=0
                local disable_24g_sta=1 disable_5g_sta=1

                config_load network
                config_load wireless
                config_foreach __repacd_disable_vap wifi-iface \
                    $network_backhaul 'ap' $disable_24g_ap $disable_5g_ap config_changed
                config_foreach __repacd_disable_vap wifi-iface \
                    $network_guest 'ap' $disable_24g_ap $disable_5g_ap config_changed

                if [ "$traffic_separation_active" -eq 1 ]; then
                    config_foreach __repacd_delete_vlan_interfaces wifi-iface \
                        $managed_network $lan_vid 'ap' net_config_changed
                    config_foreach __repacd_delete_vlan_interfaces wifi-iface \
                        $network_guest $guest_vid 'ap' net_config_changed
                    config_foreach __repacd_delete_vlan_interfaces wifi-iface \
                        $managed_network $lan_vid 'sta' net_config_changed
                    config_foreach __repacd_delete_vlan_interfaces wifi-iface \
                        $network_guest $guest_vid 'sta' net_config_changed
                    config_foreach __repacd_disable_vap wifi-iface \
                        $network_backhaul 'sta' $disable_24g_sta $disable_5g_sta config_changed
                fi
                uci_commit wireless
                uci_commit network

                __repacd_reset_additional_config
                activate_ts=1
            fi
        fi
    fi

    if [ "$wsplcd_enabled" -gt 0 ]; then
        wsplcd_restart=1
    fi

    __repacd_restart_dependencies
   if [ "$traffic_separation_enabled" -gt 0 ]; then
        __repacd_wifi_set_otherband_bssids $network_backhaul
   else
        __repacd_wifi_set_otherband_bssids $managed_network
   fi

   if [ "$activate_ts" -eq 1 ]; then
        config_load network
        config_load wireless
        config_foreach __repacd_add_vlan_interfaces wifi-iface \
            $managed_network $lan_vid 'both' net_config_changed
        config_foreach __repacd_add_vlan_interfaces wifi-iface \
            $network_guest $guest_vid $guest_backhaul_iface net_config_changed
        uci_commit wireless

        __repacd_add_ethernet_vlan_interfaces $network_guest net_config_changed
        uci_commit network

        __repacd_restart_firewall

        uci_set repacd repacd TrafficSeparationActive '1'
        uci_commit repacd

        if [ "$net_config_changed" -gt 0 ] || [ "$config_changed" -gt 0 ]; then
            config_changed=0
            hyd_stop=1
            hyd_start=1
            wsplcd_stop=1
            wsplcd_start=1
            __repacd_restart_dependencies
        fi
    fi

    if ! __repacd_gw_mode; then
        # Start the daemon that monitors link status in CAP mode, telling
        # the daemon that it is an auto config-triggered restart.
        #
        # In this mode, it will just keep checking that the link to the
        # gateway is still present on ethernet.
        start-stop-daemon -S -x /usr/sbin/repacd-run.sh -b -- \
            "son" CAP $config_re_mode $resolved_re_mode $resolved_re_submode \
            autoconf
    fi
}

# Force a restart into CAP mode using the Multi-AP SIG Topoology Optimization
# algorithm.
#
# @see restart_in_cap_mode
__restart_in_cap_mode_map() {
    stop

    # Reset the counter here in case we switch back into NonCAP (aka. RE)
    # mode. It is easier to do it here than on the NonCAP restart since
    # the latter is also used to force a bSTA change.
    __repacd_map_reset_5g_attempts

    local ether_gwcon=1 start_role='CAP' autoconf=1
    __start_map $ether_gwcon $start_role $autoconf
}

# Force a restart into CAP mode.
#
# This is used when the gateway detection logic detects a gateway on
# ethernet when running in a pure bridge mode.
restart_in_cap_mode() {
    if __repacd_is_map_enabled; then
        __restart_in_cap_mode_map
        return $?
    else
        __restart_in_cap_mode_son
        return $?
    fi
}

# Force a restart into NonCAP mode using the SON algorithms.
#
# @see restart_in_noncap_mode
__restart_in_noncap_mode_son() {
    local device_type activate_ts
    config_load repacd
    config_get managed_network repacd ManagedNetwork 'lan'
    config_get device_type repacd DeviceType 'RE'
    config_get gwcon_mode repacd GatewayConnectedMode 'AP'
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get daisy_chain WiFiLink DaisyChain '0'
    config_get backhaul_ssid repacd BackhaulSSID $def_backhaul_ssid
    config_get backhaul_enc repacd BackhaulEnc $def_backhaul_enc
    config_get backhaul_key repacd BackhaulKey $def_backhaul_key
    config_get network_guest repacd NetworkGuest 'guest'
    config_get guest_ssid repacd GuestSSID $def_guest_ssid
    config_get guest_enc repacd GuestEnc $def_guest_enc
    config_get guest_key repacd GuestKey $def_guest_key
    config_get guest_backhaul_iface repacd NetworkGuestBackhaulInterface 'both'
    config_get manage_vap_ind WiFiLink 'ManageVAPInd' '0'
    __repacd_get_config_re_mode config_re_mode
    activate_ts=0

    stop

    net_config_changed=0

    # Apply the SSID and passphrase to all interfaces to ensure that if we are
    # switching into a SON mode where there are two STA interfaces, they all
    # have the right credentials. For the non-SON and WDS modes, this is
    # subject to the RE WPS enhancement rules.
    __repacd_config_wps_pbc_enhc 0 config_changed

    __repacd_reset_existing_config

    # Need to resolve the generic NonCAP role to the actual configuration.
    if [ "$device_type" = 'RE' ]; then
        __repacd_config_re_mode

        if [ "$gwcon_mode" != "CAP" ]; then
            if [ "$traffic_separation_enabled" -gt 0 ] && \
               __repacd_is_son_mode; then
               if __repacd_check_additional_network_exist; then
                    # reset additional vaps if traffic separation enabled
                    local disable_24g_ap=0 disable_5g_ap=0

                    config_load wireless
                    # Enable spcl AP VAPs on NON-CAP only if daisy chain is enabled.
                    # They are for multi hop support. We don't need them if daisy
                    # chain is disabled.
                    if [ "$daisy_chain" -gt 0 ]; then
                        config_foreach __repacd_disable_vap wifi-iface \
                            $network_backhaul 'ap' $disable_24g_ap $disable_5g_ap config_changed
                    fi
                    config_foreach __repacd_disable_vap wifi-iface \
                        $network_guest 'ap' $disable_24g_ap $disable_5g_ap config_changed
                    uci_commit wireless

                    __repacd_reset_additional_config

                    config_load wireless
                    config_foreach __repacd_reconfig_sta_vaps wifi-iface $managed_network $network_backhaul \
                        "$backhaul_ssid" "$backhaul_enc" "$backhaul_key"
                    uci_commit wireless
                    activate_ts=1
               fi
            fi
        fi
    else
        __repacd_config_client_mode
    fi

    if [ "$wsplcd_enabled" -gt 0 ]; then
        wsplcd_restart=1
    fi

    __repacd_restart_dependencies
   if [ "$traffic_separation_enabled" -gt 0 ]; then
        __repacd_wifi_set_otherband_bssids $network_backhaul
   else
        __repacd_wifi_set_otherband_bssids $managed_network
   fi

    # create vlan interfaces required for traffic separation.
    if [ "$activate_ts" -eq 1 ]; then
        config_load network
        config_load wireless
        config_foreach __repacd_add_vlan_interfaces wifi-iface \
            $managed_network $lan_vid 'both' net_config_changed
        config_foreach __repacd_add_vlan_interfaces wifi-iface \
            $network_guest $guest_vid $guest_backhaul_iface net_config_changed
        uci_commit wireless

        __repacd_add_ethernet_vlan_interfaces $network_guest net_config_changed
        uci_commit network

        __repacd_restart_firewall

        uci_set repacd repacd TrafficSeparationActive '1'
        uci_commit repacd

        # stop/start hyd only if there is any change in netwrok config
        # due to addition of VLAN interfaces. If required VLAN iface already
        # present then we can avoid hyd stop/start. This will save some time
        # and avoid any unnecessary delays after repacd restart.
        if [ "$net_config_changed" -gt 0 ] || [ "$config_changed" -gt 0 ]; then
            config_changed=0
            hyd_stop=1
            hyd_start=1
            wsplcd_stop=1
            wsplcd_start=1
            __repacd_restart_dependencies
        fi
    fi

    if ! __repacd_gw_mode; then
        # Start the script that monitors the link state, telling the daemon that
        # it is an auto config-triggered restart.
        #
        # In this NonCAP mode, it will keep checking whether there is a link
        # to the gateway over ethernet.
        start-stop-daemon -S -x /usr/sbin/repacd-run.sh -b -- \
            "son" NonCAP $config_re_mode $resolved_re_mode \
            $resolved_re_submode autoconf
    fi
}

# Force a restart in NonCAP mode using the Multi-AP SIG Topology Optimization
# algorithm.
#
# @see restart_in_noncap_mode
__restart_in_noncap_mode_map() {
    stop

    local ether_gwcon=0 start_role='NonCAP' autoconf=1
    __start_map $ether_gwcon $start_role $autoconf
}

# Force a restart into NonCAP mode.
#
# This is used when the gateway detection logic detects that there is no
# longer a gateway connected over ethernet.
restart_in_noncap_mode() {
    if __repacd_is_map_enabled; then
        __restart_in_noncap_mode_map
        return $?
    else
        __restart_in_noncap_mode_son
        return $?
    fi
}

# Force a restart into Range Extender (RE) mode with the SON algorithms.
#
# @see restart_in_re_mode
__restart_in_re_mode_son() {
    config_load repacd
    config_get managed_network repacd ManagedNetwork 'lan'

    stop

    # By resetting the configuration, this will apply the same SSID and
    # passphrase to all interfaces. Then enable the interfaces as appropriate
    # for RE mode.
    __repacd_config_wps_pbc_enhc 0 config_changed
    __repacd_reset_existing_config
    __repacd_config_re_mode

    if [ "$wsplcd_enabled" -gt 0 ]; then
        wsplcd_restart=1
    fi

    __repacd_restart_dependencies
    __repacd_wifi_set_otherband_bssids $managed_network

    if ! __repacd_gw_mode; then
        # Start the script that monitors the link state, telling the daemon
        # that it is an auto config-triggered restart.
        #
        # In this Range Extender mode, it will keep checking whether there is
        # a link to the gateway over ethernet and that the Wi-Fi link is
        # sufficient to continue operating as an RE.
        start-stop-daemon -S -x /usr/sbin/repacd-run.sh -b -- \
            "son" RE $config_re_mode $resolved_re_mode $resolved_re_submode \
            autoconf
    fi
}

# Force a restart into Range Extender (RE) mode with the Multi-AP SIG Topology
# Optimization algorithm.
#
# @see restart_in_re_mode
__restart_in_re_mode_map() {
    stop

    local ether_gwcon=0 start_role='RE' autoconf=1
    __start_map $ether_gwcon $start_role $autoconf
}

# Force a restart into Range Extender (RE) mode.
#
# This is used when the Wi-Fi link monitoring logic determines that the
# link is in the sweet spot for a device that normally acts as a client
# but is capable (from a CPU and Wi-Fi perspective) of operating as an AP
# and a STA at the same time.
restart_in_re_mode() {
    if __repacd_is_map_enabled; then
        __restart_in_re_mode_map
        return $?
    else
        __restart_in_re_mode_son
        return $?
    fi
}
