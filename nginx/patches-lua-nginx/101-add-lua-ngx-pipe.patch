Index: nginx-1.17.7/lua-nginx/config
===================================================================
--- nginx-1.17.7.orig/lua-nginx/config
+++ nginx-1.17.7/lua-nginx/config
@@ -362,6 +362,7 @@ HTTP_LUA_SRCS=" \
             $ngx_addon_dir/src/ngx_http_lua_ssl.c \
             $ngx_addon_dir/src/ngx_http_lua_log_ringbuf.c \
             $ngx_addon_dir/src/ngx_http_lua_input_filters.c \
+            $ngx_addon_dir/src/ngx_http_lua_pipe.c \
             "
 
 HTTP_LUA_DEPS=" \
@@ -424,6 +425,7 @@ HTTP_LUA_DEPS=" \
             $ngx_addon_dir/src/ngx_http_lua_ssl.h \
             $ngx_addon_dir/src/ngx_http_lua_log_ringbuf.h \
             $ngx_addon_dir/src/ngx_http_lua_input_filters.h \
+            $ngx_addon_dir/src/ngx_http_lua_pipe.h \
             "
 
 CFLAGS="$CFLAGS -DNDK_SET_VAR"
@@ -508,6 +510,51 @@ ngx_feature_test="int rc = malloc_trim((
 SAVED_CC_TEST_FLAGS="$CC_TEST_FLAGS"
 CC_TEST_FLAGS="-Werror -Wall $CC_TEST_FLAGS"
 
+. auto/feature
+
+CC_TEST_FLAGS="$SAVED_CC_TEST_FLAGS"
+
+# ----------------------------------------
+
+ngx_feature="pipe2"
+ngx_feature_libs=
+ngx_feature_name="NGX_HTTP_LUA_HAVE_PIPE2"
+ngx_feature_run=no
+ngx_feature_incs="#include <fcntl.h>"
+ngx_feature_test="int fd[2]; pipe2(fd, O_CLOEXEC|O_NONBLOCK);"
+SAVED_CC_TEST_FLAGS="$CC_TEST_FLAGS"
+CC_TEST_FLAGS="-Werror -Wall $CC_TEST_FLAGS"
+
+. auto/feature
+
+CC_TEST_FLAGS="$SAVED_CC_TEST_FLAGS"
+
+# ----------------------------------------
+
+ngx_feature="signalfd"
+ngx_feature_libs=
+ngx_feature_name="NGX_HTTP_LUA_HAVE_SIGNALFD"
+ngx_feature_run=no
+ngx_feature_incs="#include <sys/signalfd.h>"
+ngx_feature_test="sigset_t set; signalfd(-1, &set, SFD_NONBLOCK|SFD_CLOEXEC);"
+SAVED_CC_TEST_FLAGS="$CC_TEST_FLAGS"
+CC_TEST_FLAGS="-Werror -Wall $CC_TEST_FLAGS"
+
+. auto/feature
+
+CC_TEST_FLAGS="$SAVED_CC_TEST_FLAGS"
+
+# ----------------------------------------
+
+ngx_feature="execvpe"
+ngx_feature_libs=
+ngx_feature_name="NGX_HTTP_LUA_HAVE_EXECVPE"
+ngx_feature_run=no
+ngx_feature_incs=
+ngx_feature_test='char* argv[] = {"/bin/sh"};execvpe("/bin/sh", argv, NULL);'
+SAVED_CC_TEST_FLAGS="$CC_TEST_FLAGS"
+CC_TEST_FLAGS="-Werror -Wall $CC_TEST_FLAGS"
+
 . auto/feature
 
 CC_TEST_FLAGS="$SAVED_CC_TEST_FLAGS"
Index: nginx-1.17.7/lua-nginx/src/ngx_http_lua_initworkerby.c
===================================================================
--- nginx-1.17.7.orig/lua-nginx/src/ngx_http_lua_initworkerby.c
+++ nginx-1.17.7/lua-nginx/src/ngx_http_lua_initworkerby.c
@@ -12,6 +12,7 @@
 
 #include "ngx_http_lua_initworkerby.h"
 #include "ngx_http_lua_util.h"
+#include "ngx_http_lua_pipe.h"
 
 
 static u_char *ngx_http_lua_log_init_worker_error(ngx_log_t *log,
@@ -65,6 +66,12 @@ ngx_http_lua_init_worker(ngx_cycle_t *cy
 
         return NGX_OK;
     }
+
+#ifdef HAVE_NGX_LUA_PIPE
+    if (ngx_http_lua_pipe_add_signal_handler(cycle) != NGX_OK) {
+        return NGX_ERROR;
+    }
+#endif
 #endif  /* NGX_WIN32 */
 
     if (lmcf->init_worker_handler == NULL) {
Index: nginx-1.17.7/lua-nginx/src/ngx_http_lua_module.c
===================================================================
--- nginx-1.17.7.orig/lua-nginx/src/ngx_http_lua_module.c
+++ nginx-1.17.7/lua-nginx/src/ngx_http_lua_module.c
@@ -29,6 +29,7 @@
 #include "ngx_http_lua_ssl_session_storeby.h"
 #include "ngx_http_lua_ssl_session_fetchby.h"
 #include "ngx_http_lua_headers.h"
+#include "ngx_http_lua_pipe.h"
 
 
 static void *ngx_http_lua_create_main_conf(ngx_conf_t *cf);
@@ -734,6 +735,10 @@ ngx_http_lua_init(ngx_conf_t *cf)
     cln->handler = ngx_http_lua_sema_mm_cleanup;
 #endif
 
+#ifdef HAVE_NGX_LUA_PIPE
+    ngx_http_lua_pipe_init();
+#endif
+
 #if nginx_version >= 1011011
     cln = ngx_pool_cleanup_add(cf->pool, 0);
     if (cln == NULL) {
Index: nginx-1.17.7/lua-nginx/src/ngx_http_lua_util.h
===================================================================
--- nginx-1.17.7.orig/lua-nginx/src/ngx_http_lua_util.h
+++ nginx-1.17.7/lua-nginx/src/ngx_http_lua_util.h
@@ -30,6 +30,12 @@ typedef struct {
  * user code cache table */
 extern char ngx_http_lua_code_cache_key;
 
+#define NGX_HTTP_LUA_CONTEXT_YIELDABLE (NGX_HTTP_LUA_CONTEXT_REWRITE         \
+                                | NGX_HTTP_LUA_CONTEXT_ACCESS                \
+                                | NGX_HTTP_LUA_CONTEXT_CONTENT               \
+                                | NGX_HTTP_LUA_CONTEXT_TIMER                 \
+                                | NGX_HTTP_LUA_CONTEXT_SSL_CERT              \
+                                | NGX_HTTP_LUA_CONTEXT_SSL_SESS_FETCH)
 
 /* key in Lua vm registry for all the "ngx.ctx" tables */
 #define ngx_http_lua_ctx_tables_key  "ngx_lua_ctx_tables"
Index: nginx-1.17.7/lua-nginx/src/ngx_http_lua_util.c
===================================================================
--- nginx-1.17.7.orig/lua-nginx/src/ngx_http_lua_util.c
+++ nginx-1.17.7/lua-nginx/src/ngx_http_lua_util.c
@@ -52,6 +52,7 @@
 #include "ngx_http_lua_ssl_certby.h"
 #include "ngx_http_lua_ssl.h"
 #include "ngx_http_lua_log_ringbuf.h"
+#include "ngx_http_lua_pipe.h"
 
 
 #if 1
@@ -744,6 +745,9 @@ ngx_http_lua_inject_ngx_api(lua_State *L
     ngx_http_lua_inject_timer_api(L);
     ngx_http_lua_inject_config_api(L);
     ngx_http_lua_inject_worker_api(L);
+#ifdef HAVE_NGX_LUA_PIPE
+    ngx_http_lua_inject_pipe_api(L);
+#endif
 
     ngx_http_lua_inject_misc_api(L);
 
Index: nginx-1.17.7/lua-nginx/src/ngx_http_lua_pipe.c
===================================================================
--- nginx-1.17.7.orig/lua-nginx/src/ngx_http_lua_pipe.c
+++ nginx-1.17.7/lua-nginx/src/ngx_http_lua_pipe.c
@@ -83,6 +83,7 @@ static void ngx_http_lua_pipe_proc_wait_
 static ngx_rbtree_t       ngx_http_lua_pipe_rbtree;
 static ngx_rbtree_node_t  ngx_http_lua_pipe_proc_sentinel;
 
+static char ngx_http_lua_proc_metatable_key;
 
 #if (NGX_HTTP_LUA_HAVE_SIGNALFD)
 static int                                ngx_http_lua_signalfd;
@@ -418,6 +419,8 @@ ngx_http_lua_pipe_sigchld_event_handler(
                      */
                     ngx_post_event((&pipe_node->wait_co_ctx->sleep),
                                    &ngx_posted_events);
+                } else {
+                    ngx_http_lua_pipe_proc_finalize(pipe_node->proc);
                 }
 
                 pipe_node->proc->pipe->dead = 1;
@@ -2090,7 +2093,31 @@ ngx_http_lua_pipe_read_retval_helper(ngx
 
     rc = ngx_http_lua_pipe_read(pipe, pipe_ctx);
     if (rc != NGX_AGAIN) {
-        return 0;
+        size_t buf_size = 4096;
+
+        while (1) {
+            u_char *buf, *p;
+
+            buf = ngx_pcalloc(pipe->pool, buf_size);
+            if (!buf) {
+                lua_pushnil(L);
+                lua_pushliteral(L, "no memory");
+                return 2;
+            }
+
+            p = buf;
+
+            ngx_http_lua_pipe_put_data(pipe, pipe_ctx, &p, &buf_size);
+            if (!p) {
+                ngx_pfree(pipe->pool, buf);
+                continue;
+            }
+
+            lua_pushlstring(L, (char *)buf, buf_size);
+            ngx_pfree(pipe->pool, buf);
+            break;
+        }
+        return 1;
     }
 
     rev = pipe_ctx->c->read;
@@ -2493,6 +2520,353 @@ ngx_http_lua_pipe_proc_wait_cleanup(void
     wait_co_ctx->cleanup = NULL;
 }
 
+static int lua_table_array_cnt(lua_State *L, int idx)
+{
+    int n = 0;
+
+    if (idx < 0)
+        idx = lua_gettop(L) + idx + 1;
+
+    if (!lua_istable(L, idx))
+        return 0;
+
+    lua_pushnil(L); /* stack: table key */
+
+    while (lua_next(L, idx)) { /* stack: table key value */
+        if (lua_type(L, -2) == LUA_TNUMBER) {
+            lua_Number idx = lua_tonumber(L, -2);
+            if (floor(idx) != idx || idx != n + 1)
+                goto non_array;
+            n++;
+            lua_pop(L, 1); /* stack: table key */
+            continue;
+        }
+non_array:
+        lua_pop(L, 2);
+        break;
+    }
+
+    return n;
+}
+
+static void ngx_http_lua_ngx_pipe_set_opt(lua_State *L, int idx, const char *name, int *val)
+{
+    lua_getfield(L, idx, name);
+    if (!lua_isnil(L, -1))
+        *val = lua_tointeger(L, -1);
+    lua_pop(L, 1);
+}
+
+static int ngx_http_lua_ngx_pipe_spawn(lua_State *L)
+{
+    ngx_http_lua_ffi_pipe_proc_t *proc;
+    int merge_stderr = 0;
+    int buffer_size = 4096;
+    int write_timeout = 10000;
+    int stdout_read_timeout = 10000;
+    int stderr_read_timeout = 10000;
+    int wait_timeout = 10000;
+    const char **args = NULL, **envs = NULL;
+    u_char errbuf[512] = "";
+    size_t errbuf_size = sizeof(errbuf);
+    ngx_http_request_t *r;
+    int rc = 1;
+
+    r = ngx_http_lua_get_req(L);
+    if (!r)
+        return luaL_error(L, "no request found");
+
+    if (lua_istable(L, 1)) {
+        int nargs = lua_table_array_cnt(L, 1);
+
+        if (nargs == 0)
+            return luaL_error(L, "bad args arg: non-empty table expected");
+        
+        args = ngx_pcalloc(r->pool, sizeof(char *) * (nargs + 1));
+
+        for (int i = 0; i < nargs; i++) {
+            lua_rawgeti(L, 1, i + 1);
+            args[i] = lua_tostring(L, -1);
+            lua_pop(L, 1);
+        }
+    } else if (lua_isstring(L, 1)) {
+        args = ngx_pcalloc(r->pool, sizeof(char *) * 4);
+        args[0] = "/bin/sh";
+        args[1] = "-c";
+        args[2] = lua_tostring(L, 1);
+    } else {
+        return luaL_error(L, "bad args arg: table expected, got '%s'", lua_typename(L, lua_type(L, 1)));
+    }
+
+    if (lua_istable(L, 2)) {
+        lua_getfield(L, 2, "merge_stderr");
+        merge_stderr = lua_toboolean(L, -1);
+        lua_pop(L, 1);
+
+        ngx_http_lua_ngx_pipe_set_opt(L, 2, "buffer_size", &buffer_size);
+        ngx_http_lua_ngx_pipe_set_opt(L, 2, "write_timeout", &write_timeout);
+        ngx_http_lua_ngx_pipe_set_opt(L, 2, "stdout_read_timeout", &stdout_read_timeout);
+        ngx_http_lua_ngx_pipe_set_opt(L, 2, "stderr_read_timeout", &stderr_read_timeout);
+        ngx_http_lua_ngx_pipe_set_opt(L, 2, "wait_timeout", &wait_timeout);
+
+        lua_getfield(L, 2, "environ");
+        if (lua_istable(L, -1)) {
+            int nenv = lua_table_array_cnt(L, -1);
+
+            envs = ngx_pcalloc(r->pool, sizeof(char *) * (nenv + 1));
+
+            for (int i = 0; i < nenv; i++) {
+                lua_rawgeti(L, -1, i + 1);
+                envs[i] = lua_tostring(L, -1);
+                lua_pop(L, 1);
+            }
+        }
+        lua_pop(L, 1);
+    }
+
+    proc = lua_newuserdata(L, sizeof(ngx_http_lua_ffi_pipe_proc_t));
+    if (!proc) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "no memory");
+        rc = 2;
+        goto free_mem;
+    }
+
+    proc->write_timeout = write_timeout;
+    proc->stdout_read_timeout = stdout_read_timeout;
+    proc->stderr_read_timeout = stderr_read_timeout;
+    proc->wait_timeout = wait_timeout;
+
+    lua_pushlightuserdata(L, &ngx_http_lua_proc_metatable_key);
+    lua_rawget(L, LUA_REGISTRYINDEX);
+    lua_setmetatable(L, -2);
+
+    rc = ngx_http_lua_ffi_pipe_spawn(proc, args[0], args, merge_stderr, buffer_size, envs,
+            errbuf, &errbuf_size);
+    if (rc != NGX_OK) {
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *)errbuf, errbuf_size);
+        rc = 2;
+    } else {
+        rc = 1;
+    }
+
+free_mem:
+    if (args)
+        ngx_pfree(r->pool, args);
+    if (envs)
+        ngx_pfree(r->pool, envs);
+    return rc;
+}
+
+static int ngx_http_lua_proc_pid(lua_State *L)
+{
+    ngx_http_lua_ffi_pipe_proc_t *proc = lua_touserdata(L, 1);
+
+    lua_pushinteger(L, proc->_pid);
+    return 1;
+}
+
+static int ngx_http_lua_proc_wait(lua_State *L)
+{
+    ngx_http_lua_ffi_pipe_proc_t *proc = lua_touserdata(L, 1);
+    ngx_http_request_t *r;
+    char *reason;
+    int status;
+    u_char errbuf[128] = "";
+    size_t errbuf_size = sizeof(errbuf);
+    int rc;
+
+    r = ngx_http_lua_get_req(L);
+    if (!r)
+        return luaL_error(L, "no request found");
+
+    rc = ngx_http_lua_ffi_pipe_proc_wait(r, proc, &reason, &status, errbuf, &errbuf_size);
+    switch (rc) {
+    case NGX_OK:
+        lua_pushboolean(L, 1);
+        lua_pushstring(L, reason);
+        lua_pushinteger(L, status);
+        return 3;
+    case NGX_DECLINED:
+        lua_pushboolean(L, 0);
+        lua_pushstring(L, reason);
+        lua_pushinteger(L, status);
+        return 3;
+    case NGX_ERROR:
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *)errbuf, errbuf_size);
+        return 2;
+    default:
+        return lua_yield(L, 0);
+    }
+}
+
+static int ngx_http_lua_proc_kill(lua_State *L)
+{
+    ngx_http_lua_ffi_pipe_proc_t *proc = lua_touserdata(L, 1);
+    u_char errbuf[128] = "";
+    size_t errbuf_size = sizeof(errbuf);
+    int signal;
+    int rc;
+
+    signal = luaL_checkinteger(L, 2);
+
+    rc = ngx_http_lua_ffi_pipe_proc_kill(proc, signal, errbuf, &errbuf_size);
+    if (rc == NGX_OK) {
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *)errbuf, errbuf_size);
+        return 2;
+    }
+
+    lua_pushboolean(L, 1);
+    return 1;
+}
+
+static int ngx_http_lua_proc_read(lua_State *L, int from_stderr, int reader_type)
+{
+    ngx_http_lua_ffi_pipe_proc_t *proc = lua_touserdata(L, 1);
+    ssize_t len = lua_tointeger(L, 2);
+    ngx_http_lua_pipe_ctx_t *pipe_ctx;
+    ngx_http_request_t *r;
+    u_char *buf, *p;
+    size_t buf_size = 4096;
+    u_char errbuf[128] = "";
+    size_t errbuf_size = sizeof(errbuf);
+    int rc;
+
+    switch (reader_type) {
+    case PIPE_READ_BYTES:
+        if (len <= 0) {
+            if (len < 0)
+                return luaL_error(L, "bad len argument");
+            lua_pushliteral(L, "");
+            return 1;
+        }
+        break;
+    case PIPE_READ_ANY:
+        if (len <= 0)
+            return luaL_error(L, "bad max argument");
+        break;
+    default:
+        len = 0;
+        break;
+    }
+
+    r = ngx_http_lua_get_req(L);
+    if (!r)
+        return luaL_error(L, "no request found");
+
+    buf = ngx_pcalloc(proc->pipe->pool, buf_size);
+    p = buf;
+
+    if (!p) {
+        lua_pushnil(L);
+        lua_pushliteral(L, "no memory");
+        return 2;
+    }
+
+    rc = ngx_http_lua_ffi_pipe_proc_read(r, proc, from_stderr, reader_type, len, &p,
+                                                    &buf_size, errbuf,
+                                                    &errbuf_size);
+    if (rc == NGX_OK || rc == NGX_DECLINED) {
+        if (!p) {
+            if (from_stderr)
+                pipe_ctx = proc->pipe->stderr_ctx;
+            else
+                pipe_ctx = proc->pipe->stdout_ctx;
+
+            ngx_pfree(proc->pipe->pool, buf);
+
+            buf = ngx_pcalloc(proc->pipe->pool, buf_size);
+            if (!buf) {
+                lua_pushnil(L);
+                lua_pushliteral(L, "no memory");
+                return 2;
+            }
+            ngx_http_lua_pipe_put_data(proc->pipe, pipe_ctx, &buf, &buf_size);
+        }
+
+        if (rc == NGX_OK) {
+            lua_pushlstring(L, (char *)buf, buf_size);
+            ngx_pfree(proc->pipe->pool, buf);
+            return 1;
+        }
+
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *)errbuf, errbuf_size);
+        lua_pushlstring(L, (char *)buf, buf_size);
+        ngx_pfree(proc->pipe->pool, buf);
+        return 3;
+    }
+
+    if (rc == NGX_ERROR) {
+        lua_pushnil(L);
+        lua_pushlstring(L, (char *)errbuf, errbuf_size);
+        ngx_pfree(proc->pipe->pool, buf);
+        return 2;
+    }
+
+    ngx_pfree(proc->pipe->pool, buf);
+
+    return lua_yield(L, 0);
+}
+
+#define NGX_LUA_PIPE_DEF_READ_FUN(name, from_stderr, reader_type)   \
+    static int ngx_http_lua_proc_##name(lua_State *L)               \
+    {                                                               \
+        return ngx_http_lua_proc_read(L, from_stderr, reader_type); \
+    }
+
+NGX_LUA_PIPE_DEF_READ_FUN(stdout_read_all, 0, PIPE_READ_ALL)
+NGX_LUA_PIPE_DEF_READ_FUN(stdout_read_bytes, 0, PIPE_READ_BYTES)
+NGX_LUA_PIPE_DEF_READ_FUN(stdout_read_line, 0, PIPE_READ_LINE)
+NGX_LUA_PIPE_DEF_READ_FUN(stdout_read_any, 0, PIPE_READ_ANY)
+
+NGX_LUA_PIPE_DEF_READ_FUN(stderr_read_all, 1, PIPE_READ_ALL)
+NGX_LUA_PIPE_DEF_READ_FUN(stderr_read_bytes, 1, PIPE_READ_BYTES)
+NGX_LUA_PIPE_DEF_READ_FUN(stderr_read_line, 1, PIPE_READ_LINE)
+NGX_LUA_PIPE_DEF_READ_FUN(stderr_read_any, 1, PIPE_READ_ANY)
+
+#define NGX_LUA_PIPE_ADD_FUN(name)                 \
+    do {                                                \
+        lua_pushcfunction(L, ngx_http_lua_proc_##name); \
+        lua_setfield(L, -2, #name);                      \
+    } while (0)
+
+void ngx_http_lua_inject_pipe_api(lua_State *L)
+{
+    lua_createtable(L, 0 /* narr */, 1 /* nrec */);    /* ngx.pipe. */
+
+    lua_pushcfunction(L, ngx_http_lua_ngx_pipe_spawn);
+    lua_setfield(L, -2, "spawn");
+
+    lua_setfield(L, -2, "pipe");
+
+    /* {{{proc object metatable */
+    lua_pushlightuserdata(L, &ngx_http_lua_proc_metatable_key);
+
+    lua_createtable(L, 0 /* narr */, 2 /* nrec */); /* mt */
+
+    lua_createtable(L, 0 /* narr */, 11 /* nrec */); /* __index */
+
+    NGX_LUA_PIPE_ADD_FUN(pid);
+    NGX_LUA_PIPE_ADD_FUN(wait);
+    NGX_LUA_PIPE_ADD_FUN(kill);
+    NGX_LUA_PIPE_ADD_FUN(stdout_read_all);
+    NGX_LUA_PIPE_ADD_FUN(stdout_read_bytes);
+    NGX_LUA_PIPE_ADD_FUN(stdout_read_line);
+    NGX_LUA_PIPE_ADD_FUN(stdout_read_any);
+    NGX_LUA_PIPE_ADD_FUN(stderr_read_all);
+    NGX_LUA_PIPE_ADD_FUN(stderr_read_bytes);
+    NGX_LUA_PIPE_ADD_FUN(stderr_read_line);
+    NGX_LUA_PIPE_ADD_FUN(stderr_read_any);
+
+    lua_setfield(L, -2, "__index");
+
+    lua_rawset(L, LUA_REGISTRYINDEX);
+    /* }}} */
+}
 
 #endif /* HAVE_NGX_LUA_PIPE */
 
Index: nginx-1.17.7/lua-nginx/src/ngx_http_lua_pipe.h
===================================================================
--- nginx-1.17.7.orig/lua-nginx/src/ngx_http_lua_pipe.h
+++ nginx-1.17.7/lua-nginx/src/ngx_http_lua_pipe.h
@@ -86,6 +86,7 @@ typedef struct {
 
 void ngx_http_lua_pipe_init(void);
 ngx_int_t ngx_http_lua_pipe_add_signal_handler(ngx_cycle_t *cycle);
+void ngx_http_lua_inject_pipe_api(lua_State *L);
 #endif
 
 
